<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Dart 系列之数据类型]]></title>
    <url>%2F2020%2F01%2F17%2FDart%20%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型 Dart 语言内建类型： Number String Boolean List Map Set Rune Symbol 接下来一起来看每种类型的详细用法（配有相关代码示例）。 Number int 和 double 都是 num. 的亚类型。 num 类型包括基本运算 +， -， /， 和 *， 以及 abs()，ceil()， 和 floor()， 等函数方法。 （按位运算符，例如»，定义在 int 类中。） 如果 num 及其亚类型找不到你想要的方法， 尝试查找使用 dart:math 库。 int 整数值不大于64位， 具体取决于平台。 在 Dart VM 上， 值的范围从 -263 到 263 - 1. Dart 被编译为 JavaScript 时，使用 JavaScript numbers, 值的范围从 -253 到 253 - 1. double 64位（双精度）浮点数，依据 IEEE 754 标准。 12345678910111213141516171819202122232425262728293031323334// 定义整数类形var x = 1;var hex = 0xD82940;// 定义 double 类型var y = 3.14;var exponents = 1.42e5; // 从 Dart 2.1 开始，必要的时候 int 字面量会自动转换成 double 类型。double z = 1; // 相当于 double z = 1.0.print("------------------- 分割线 ---------------------");// 数据类型转换// String -&gt; intvar num = int.parse("12306");assert(num == 12306);// String -&gt; doublevar dob = double.parse("3.1415926");assert(dob == 3.1415926); // int -&gt; Stringvar int2str = 18.toString();assert(int2str == "18"); // double -&gt; Stringvar dob2str = 3.1415.toString();assert(dob2str == "3.1415"); // 按位操作:移位（&lt;&lt;， &gt;&gt;），按位与（&amp;）以及 按位或（|）assert((3 &lt;&lt; 1) == 6); // 0011 &lt;&lt; 1 == 0110assert((3 &gt;&gt; 1) == 1); // 0011 &gt;&gt; 1 == 0001assert((3 | 4) == 7); // 0011 | 0100 == 0111 String Dart 字符串是一组 UTF-16 单元序列。 字符串通过单引号或者双引号创建。字符串可以通过 ${expression} 的方式内嵌表达式。 123456789101112131415161718192021222324// 字符串创建var s1 = "create s1 string";var s2 = "create s2 string";var s3 = "create s3 string";var s = "Hello Dart, test";assert("create s1 string $s" == s1 + " Hello Dart, test");// 字符串拼接var str = s1 + s2 + s3;print(str);// 创建多行字符串var multipleStr = """ 三里清风三里路， 步步清风再无你。""";print(multipleStr);// 创建原始字符串：使用 r 作为前缀var strs = "http://www.baidu. \ncom";var originalStr = r"http://www.baidu. \ncom";print(strs);print(originalStr); Boolean Dart 使用 bool 类型表示布尔值。 Dart 只有字面量 true and false 是布尔类型， 这两个对象都是编译时常量。 123456789101112131415// 检查空字符串/非空字符串var emptyStr = "";assert(emptyStr.isEmpty);// 判断 0 值var hintPoint = 0;assert(hintPoint &lt;= 0);// 检查 null 值var unicon;assert(unicon == null);// 检查 NaNvar iMeantToDoThis = 0 / 0;assert(iMeantToDoThis.isNaN); List Dart 中的 Array 就是 List 对象， 通常称之为 List 。 123456789101112131415161718192021222324252627// 创建列表var list = [1, 2, 3, 4, 5];print(list);// 获取 list 的长度print(list.length);// 访问列表的元素print(list[1] == 2);// 在 List 字面量之前添加 const 关键字，可以定义 List 类型的编译时常量var constantList = const [1, 2, 3, true];// constantList[1] = 1; // 取消注释会引起错误。// 添加元素list.insert(5, 6);list.add(7);print(list);// 删除元素list.removeAt(6);list.remove(6);print(list);// 清除元素list.clear();print(list); Map 通常来说， Map 是用来关联 keys 和 values 的对象。 keys 和 values 可以是任何类型的对象。在一个 Map 对象中一个 key 只能出现一次。 但是 value 可以出现多次。 Dart 中 Map 通过 Map 字面量 和 Map 类型来实现。 1234567891011121314151617181920212223242526272829303132333435363738// 创建泛型为&lt;String, String&gt;var gifts = &#123; // Key: Value "first": "Apple", "second": "ring", "third": "videos"&#125;;// 创建泛型为&lt;int, String&gt;var nodeCase = &#123;0: "apple", 1: "banana", 2: "car", 3: "dot"&#125;;// 添加var gift = Map(); // 等价于 var gift = new Map();gift['first'] = 'Apple'; // add key - valuegift['second'] = 'Banana';gift['third'] = 'Car';var node = Map();node[0] = 'apple';node[1] = 'banana';node[2] = 'car';node[3] = 'dot';assert(gift['first'] == 'Apple');// 当 Map 中不存在 key 的时候会返回 nullassert(gift['fourth'] == null);// 获取 Map 的长度print(gift.length);// 创建 Map 类型运行时常量，要在 Map 字面量前加上关键字 const。final constantMap = const &#123; 2: 'helium', 10: 'neon', 18: 'argon',&#125;;// constantMap[2] = 'Helium'; // Error Set Dart 中 Set 是一个元素唯一且无需的集合。 Dart 为 Set 提供了 Set 字面量和 Set 类型。 12345678910111213141516171819202122232425262728// 创建var createSet = &#123;"one", "two", "three", "four"&#125;; // 自动推断泛型为 Stringvar nullSet = &lt;String&gt;&#123;&#125;; // 创建空的 Set 对象// Set&lt;String&gt; names = &#123;&#125;; // 这样也是可以的。// &#123;&#125; 默认是 Map 类型// var names = &#123;&#125;; // 这样会创建一个 Map ，而不是 Set 。print(createSet);// Set 的相关操作// 添加var elements = &lt;String&gt;&#123;&#125;;elements.add("Apple");elements.addAll(createSet);print(elements);// 获取 Set 长度print(elements.length);// 创建一个编译时 Set 常量final constantSet = const &#123; 'Apple', 'Banana', 'Carrot', 'Dot', 'Earth',&#125;;// constantSet.add('Dot'); // Uncommenting this causes an error.print(constantSet); Rune(在字符串中标识 Unicode 字符) 在 Dart 中， Rune 用来表示字符串中的 UTF-32 编码字符。Unicode 定义了一个全球的书写系统编码， 系统中使用的所有字母，数字和符号都对应唯一的数值编码。 由于 Dart 字符串是一系列 UTF-16 编码单元， 因此要在字符串中表示 32 位 Unicode 值需要特殊语法支持。表示 Unicode 编码的常用方法是， \uXXXX, 这里 XXXX 是一个4位的16进制数。 12345// Rune 格式：\u&#123;xxxx&#125;var simle = "\u&#123;1f600&#125;";var heartShape = "\u&#123;2665&#125;";print(simle + " -- " + heartShape); // 😀 -- ♥ Symbol 一个 Symbol 对象表示 Dart 程序中声明的运算符或者标识符。 你也许永远都不需要使用 Symbol ，但要按名称引用标识符的 API 时， Symbol 就非常有用了。 因为代码压缩后会改变标识符的名称，但不会改变标识符的符号。 通过字面量 Symbol ，也就是标识符前面添加一个 # 号，来获取标识符的 Symbol 。 12345var radix = #radix;var bar = #bar;print(radix); // Symbol("radix")print(bar); // Symbol("bar") 至此，Dart 系列之数据类型就结束了，如有任何问题，欢迎交流和指正。]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
        <tag>开发环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart 系列之数据类型]]></title>
    <url>%2F2020%2F01%2F17%2FDart%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Dart 系列之数据类型数据类型 Dart 语言内建类型： Number String Boolean List Map Set Rune Symbol 接下来一起来看每种类型的详细用法（配有相关代码示例）。 Number int 和 double 都是 num. 的亚类型。 num 类型包括基本运算 +， -， /， 和 *， 以及 abs()，ceil()， 和 floor()， 等函数方法。 （按位运算符，例如»，定义在 int 类中。） 如果 num 及其亚类型找不到你想要的方法， 尝试查找使用 dart:math 库。 int 整数值不大于64位， 具体取决于平台。 在 Dart VM 上， 值的范围从 -263 到 263 - 1. Dart 被编译为 JavaScript 时，使用 JavaScript numbers, 值的范围从 -253 到 253 - 1. double 64位（双精度）浮点数，依据 IEEE 754 标准。 12345678910111213141516171819202122232425262728293031323334// 定义整数类形var x = 1;var hex = 0xD82940;// 定义 double 类型var y = 3.14;var exponents = 1.42e5; // 从 Dart 2.1 开始，必要的时候 int 字面量会自动转换成 double 类型。double z = 1; // 相当于 double z = 1.0.print("------------------- 分割线 ---------------------");// 数据类型转换// String -&gt; intvar num = int.parse("12306");assert(num == 12306);// String -&gt; doublevar dob = double.parse("3.1415926");assert(dob == 3.1415926); // int -&gt; Stringvar int2str = 18.toString();assert(int2str == "18"); // double -&gt; Stringvar dob2str = 3.1415.toString();assert(dob2str == "3.1415"); // 按位操作:移位（&lt;&lt;， &gt;&gt;），按位与（&amp;）以及 按位或（|）assert((3 &lt;&lt; 1) == 6); // 0011 &lt;&lt; 1 == 0110assert((3 &gt;&gt; 1) == 1); // 0011 &gt;&gt; 1 == 0001assert((3 | 4) == 7); // 0011 | 0100 == 0111 String Dart 字符串是一组 UTF-16 单元序列。 字符串通过单引号或者双引号创建。字符串可以通过 ${expression} 的方式内嵌表达式。 123456789101112131415161718192021222324// 字符串创建var s1 = "create s1 string";var s2 = "create s2 string";var s3 = "create s3 string";var s = "Hello Dart, test";assert("create s1 string $s" == s1 + " Hello Dart, test");// 字符串拼接var str = s1 + s2 + s3;print(str);// 创建多行字符串var multipleStr = """ 三里清风三里路， 步步清风再无你。""";print(multipleStr);// 创建原始字符串：使用 r 作为前缀var strs = "http://www.baidu. \ncom";var originalStr = r"http://www.baidu. \ncom";print(strs);print(originalStr); Boolean Dart 使用 bool 类型表示布尔值。 Dart 只有字面量 true and false 是布尔类型， 这两个对象都是编译时常量。 123456789101112131415// 检查空字符串/非空字符串var emptyStr = "";assert(emptyStr.isEmpty);// 判断 0 值var hintPoint = 0;assert(hintPoint &lt;= 0);// 检查 null 值var unicon;assert(unicon == null);// 检查 NaNvar iMeantToDoThis = 0 / 0;assert(iMeantToDoThis.isNaN); List Dart 中的 Array 就是 List 对象， 通常称之为 List 。 123456789101112131415161718192021222324252627// 创建列表var list = [1, 2, 3, 4, 5];print(list);// 获取 list 的长度print(list.length);// 访问列表的元素print(list[1] == 2);// 在 List 字面量之前添加 const 关键字，可以定义 List 类型的编译时常量var constantList = const [1, 2, 3, true];// constantList[1] = 1; // 取消注释会引起错误。// 添加元素list.insert(5, 6);list.add(7);print(list);// 删除元素list.removeAt(6);list.remove(6);print(list);// 清除元素list.clear();print(list); Map 通常来说， Map 是用来关联 keys 和 values 的对象。 keys 和 values 可以是任何类型的对象。在一个 Map 对象中一个 key 只能出现一次。 但是 value 可以出现多次。 Dart 中 Map 通过 Map 字面量 和 Map 类型来实现。 1234567891011121314151617181920212223242526272829303132333435363738// 创建泛型为&lt;String, String&gt;var gifts = &#123; // Key: Value "first": "Apple", "second": "ring", "third": "videos"&#125;;// 创建泛型为&lt;int, String&gt;var nodeCase = &#123;0: "apple", 1: "banana", 2: "car", 3: "dot"&#125;;// 添加var gift = Map(); // 等价于 var gift = new Map();gift['first'] = 'Apple'; // add key - valuegift['second'] = 'Banana';gift['third'] = 'Car';var node = Map();node[0] = 'apple';node[1] = 'banana';node[2] = 'car';node[3] = 'dot';assert(gift['first'] == 'Apple');// 当 Map 中不存在 key 的时候会返回 nullassert(gift['fourth'] == null);// 获取 Map 的长度print(gift.length);// 创建 Map 类型运行时常量，要在 Map 字面量前加上关键字 const。final constantMap = const &#123; 2: 'helium', 10: 'neon', 18: 'argon',&#125;;// constantMap[2] = 'Helium'; // Error Set Dart 中 Set 是一个元素唯一且无需的集合。 Dart 为 Set 提供了 Set 字面量和 Set 类型。 12345678910111213141516171819202122232425262728// 创建var createSet = &#123;"one", "two", "three", "four"&#125;; // 自动推断泛型为 Stringvar nullSet = &lt;String&gt;&#123;&#125;; // 创建空的 Set 对象// Set&lt;String&gt; names = &#123;&#125;; // 这样也是可以的。// &#123;&#125; 默认是 Map 类型// var names = &#123;&#125;; // 这样会创建一个 Map ，而不是 Set 。print(createSet);// Set 的相关操作// 添加var elements = &lt;String&gt;&#123;&#125;;elements.add("Apple");elements.addAll(createSet);print(elements);// 获取 Set 长度print(elements.length);// 创建一个编译时 Set 常量final constantSet = const &#123; 'Apple', 'Banana', 'Carrot', 'Dot', 'Earth',&#125;;// constantSet.add('Dot'); // Uncommenting this causes an error.print(constantSet); Rune(在字符串中标识 Unicode 字符) 在 Dart 中， Rune 用来表示字符串中的 UTF-32 编码字符。Unicode 定义了一个全球的书写系统编码， 系统中使用的所有字母，数字和符号都对应唯一的数值编码。 由于 Dart 字符串是一系列 UTF-16 编码单元， 因此要在字符串中表示 32 位 Unicode 值需要特殊语法支持。表示 Unicode 编码的常用方法是， \uXXXX, 这里 XXXX 是一个4位的16进制数。 12345// Rune 格式：\u&#123;xxxx&#125;var simle = "\u&#123;1f600&#125;";var heartShape = "\u&#123;2665&#125;";print(simle + " -- " + heartShape); // 😀 -- ♥ Symbol 一个 Symbol 对象表示 Dart 程序中声明的运算符或者标识符。 你也许永远都不需要使用 Symbol ，但要按名称引用标识符的 API 时， Symbol 就非常有用了。 因为代码压缩后会改变标识符的名称，但不会改变标识符的符号。 通过字面量 Symbol ，也就是标识符前面添加一个 # 号，来获取标识符的 Symbol 。 12345var radix = #radix;var bar = #bar;print(radix); // Symbol("radix")print(bar); // Symbol("bar") 至此，Dart 系列之数据类型就结束了，如有任何问题，欢迎交流和指正。]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
        <tag>开发环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart 系列之环境搭建]]></title>
    <url>%2F2020%2F01%2F15%2FDart%20%E7%B3%BB%E5%88%97%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Dart 系列之环境搭建环境搭建个人的开发环境基于 IntelliJ IDEA 来搭建，所以这篇文章是以 IntelliJ IDEA 为例。 下载 SDK 并配置环境变量。 安装 Dart 插件。 配置已安装的 SDK 插件路径。 下载 SDK 并配置环境变量 Dart SDK 下载地址：Dart SDK 下载，支持 Windows、Linux、Mac 三大平台的安装。 Windows Linux Mac 注：这里需要额外说明一下，不建议使用命令安装 SDK，建议使用如下链家安装：https://www.gekorm.com/dart-windows 配置环境变量 我的电脑 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量 –&gt; Path 添加已安装的 SDK 路径（E:\Dart\dart-sdk\bin） –&gt; 保存 安装 Dart 插件打开 IDEA, File -&gt; Settings -&gt; Plugins,搜索 Dart 点击安装完成后，重新启动 IDEA 。 配置已安装的 SDK 插件路径 选择新建项目类型并设置已安装 SDK 的路径 ![配置 SDK 路径](D:\Work\github_file\SimplationWANGBlogs\source\dart source\配置 SDK 路径.png) 设置项目名称和路径 ![设置项目名称和路径](D:\Work\github_file\SimplationWANGBlogs\source\dart source\设置项目名称和路径.png) 点击 Finish 然后就可以愉快的玩耍。 至此，Dart 环境搭建就结束了，如有任何问题，欢迎交流`和指正。]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
        <tag>开发环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart 系列之环境搭建]]></title>
    <url>%2F2020%2F01%2F15%2FDart%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Dart 系列之环境搭建环境搭建个人的开发环境基于 IntelliJ IDEA 来搭建，所以这篇文章是以 IntelliJ IDEA 为例。 下载 SDK 并配置环境变量。 安装 Dart 插件。 配置已安装的 SDK 插件路径。 下载 SDK 并配置环境变量 Dart SDK 下载地址：Dart SDK 下载，支持 Windows、Linux、Mac 三大平台的安装。 Windows Linux Mac 注：这里需要额外说明一下，不建议使用命令安装 SDK，建议使用如下链家安装：https://www.gekorm.com/dart-windows 配置环境变量 我的电脑 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量 –&gt; Path 添加已安装的 SDK 路径（E:\Dart\dart-sdk\bin） –&gt; 保存 安装 Dart 插件打开 IDEA, File -&gt; Settings -&gt; Plugins,搜索 Dart 点击安装完成后，重新启动 IDEA 。 配置已安装的 SDK 插件路径 选择新建项目类型并设置已安装 SDK 的路径 ![配置 SDK 路径](D:\Work\github_file\SimplationWANGBlogs\source\dart source\配置 SDK 路径.png) 设置项目名称和路径 ![设置项目名称和路径](D:\Work\github_file\SimplationWANGBlogs\source\dart source\设置项目名称和路径.png) 点击 Finish 然后就可以愉快的玩耍。 至此，Dart 环境搭建就结束了，如有任何问题，欢迎交流`和指正。]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
        <tag>开发环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 关键字整理.md]]></title>
    <url>%2F2019%2F09%2F28%2FJava%20%E5%85%B3%E9%94%AE%E5%AD%97%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java 关键字 概念：Java 关键字是对 Java 编译器有特殊含义的字符串，是编译器和程序员的一个约定，程序员利用关键字来告诉编译器其声明的变量类型、类、方法特性等信息。 关键字整理 关键字 含义 abstract 表明类或者成员方法具有抽象属性 assert 断言，用来进行程序调试 boolean 基本数据类型之一，声明布尔类型的关键字 break 提前跳出一个块 byte 基本数据类型之一，字节类型 case 用在 switch 语句之中，表示其中的一个分支 catch 用在异常处理中，用来捕捉异常 char 基本数据类型之一，字符类型 class 声明一个类 const 保留关键字，没有具体含义 continue 回到一个块的开始处 default 默认，例如，用在 switch 语句中，表明一个默认的分支。Java8 中也作用于声明接口函数的默认实现 do 用在 do-while 循环结构中 double 基本数据类型之一，双精度浮点数类型 else 用在条件语句中，表明当条件不成立时的分支 enum 枚举 extends 表明一个类型是另一个类型的子类型。对于类，可以是另一个类或者抽象类；对于接口，可以是另一个接口 final 用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量 finally 用于处理异常情况，用来声明一个基本肯定会被执行到的语句块 float 基本数据类型之一，单精度浮点数类型 for 一种循环结构的引导词 goto 保留关键字，没有具体含义 if 条件语句的引导词 implements 表明一个类实现了给定的接口 import 表明要访问指定的类或包 instanceof 用来测试一个对象是否是指定类型的实例对象 int 基本数据类型之一，整数类型 interface 接口 long 基本数据类型之一，长整数类型 native 用来声明一个方法是由与计算机相关的语言（如 C / C++ / FORTRAN 语言）实现的 new 用来创建新实例对象 package 包 private 一种访问控制方式：私用模式 protected 一种访问控制方式：保护模式 public 一种访问控制方式：共用模式 return 从成员方法中返回数据 short 基本数据类型之一,短整数类型 static 表明具有静态属性 strictfp 用来声明 FP_strict（单精度或双精度浮点数）表达式遵循 IEEE 754 算术规范 super 表明当前对象的父类型的引用或者父类型的构造方法 switch 分支语句结构的引导词 synchronized 表明一段代码需要同步执行 this 指向当前实例对象的引用 throw 抛出一个异常 throws 声明在当前定义的成员方法中所有需要抛出的异常 transient 声明不用序列化的成员域 try 尝试一个可能抛出异常的程序块 void 声明当前成员方法没有返回值 volatile 表明两个或者多个变量必须同步地发生变化 while 用在循环结构中 分类 数据类型： 用于数据类型的关键字有 boolean、byte、char、 double、 false、float、int、long、new、null、short、true、void、instanceof； 语句： 用于语句的关键字有 break、case、 catch、 continue、 default 、do、 else、 for、 if、return、switch、try、 while、 finally、 throw、this、 super； 修饰： 用于修饰的关键字有 abstract、final、native、private、 protected、public、static、synchronized、 transient、 volatile； 方法、类、接口、包和异常： 用于方法、类、接口、包和异常的关键字有 class、 extends、 implements、interface、 package、import、throws； 还有些关键字,如 cat、 future、 generic、innerr、 operator、 outer、rest、var 等都是 Java 保留的没有意义的关键字。 使用介绍 示例代码为伪代码，无法正常运行。 abstract abstract 关键字可以修饰类或方法。abstract 类可以扩展（增加子类），但不能直接实例化。abstract 方法不在声明它的类中实现，但必须在某个子类中重写。 示例 12345public abstract class MyClass&#123;&#125;public abstract String myMethod();-注释-采用 abstract 方法的类本来就是抽象类，并且必须声明为 abstract。abstract 类不能实例化。仅当 abstract 类的子类实现其超类的所有 abstract 方法时，才能实例化 abstract 类的子类。这种类称为具体类，以区别于 abstract 类。如果 abstract 类的子类没有实现其超类的所有 abstract 方法，该子类也是 abstract 类。abstract 关键字不能应用于 static、private 或 final 方法，因为这些方法不能被重写，因此，不能在子类中实现。final 类的方法都不能是 abstract，因为 final 类不能有子类。 boolean boolean 变量的值可以是 true 或 false。 示例 12345678boolean valid = true;if (valid) &#123; &lt;statement&gt;&#125;-注释-boolean 变量只能以 true 或 false 作为值。boolean 不能与数字类型相互转换。包含 boolean 操作数的表达式只能包含 boolean 操作数。Boolean 类是 boolean 原始类型的包装对象类。 break 用于提前退出 for、while 或 do 循环，或者在 switch 语句中用来结束 case 块。 示例 1234567891011121314151617181920212223for (i = 0; i &lt; max; i++) &#123; if (&lt;loop finished early &gt;) &#123; break; &#125;&#125;int type = &lt;some value&gt;;switch (type) &#123; case1: &lt;statement&gt; break; case2: &lt;statement&gt; break; default: &lt;statement&gt; break;&#125;-注释-break 总是退出最深层的 while、for、do 或 switch 语句 byte byte 是 Java 原始类型。byte 可存储在 [-128,127] 范围以内的整数值。 示例 1234byteb = 124;-示例-Byte 类是 byte 原始类型的包装对象类。它定义代表此类型的值的范围的MIN_VALUE和MAX_VALUE常量。Java 中的所有整数值都是 32 位的 int 值，除非值后面有 l 或 L（如 235L），这表示该值应解释为 long 。 case 用来标记 switch 语句中的每个分支。 示例 123456789101112131415161718int type = &lt;some value&gt;;switch (type) &#123; case1: &lt;statement&gt; break; case2: &lt;statement&gt; break; default: &lt;statement&gt; break;&#125;-示例-case 块没有隐式结束点。break 语句通常在每个 case 块末尾使用，用于退出 switch 语句。如果没有 break 语句，执行流将进入所有后面的 case 和/或 default 块。 catch catch 关键字用来在 try-catch 或 try-catch-finally 语句中定义异常处理块。 示例 12345678910try &#123; &lt;可能引发异常的块&gt;&#125; catch (&lt;java.lang.Exception或子类 &gt; e) &#123; &lt;处理异常e的代码&gt;&#125; finally &#123; &lt;有异常或无异常情况下都执行的语句&gt;&#125;-示例-开始和结束标记&#123;和&#125;是 catch 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。每个 try 块都必须至少有一个 catch 或 finally 子句。如果某个特定异常类未被任何 catch 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 try 块。如果任何封闭 try 块都未捕获到异常，Java 解释器将退出，并显示错误消息和堆栈跟踪信息。 char char 是 Java 原始类型。char 变量可以存储一个 Unicode 字符。 示例 1234567891011121314151617char delimiter = ';';-注释-可以使用下列 char 常量：\b-空格\f-换页\n-换行\r-回车\t-水平制表符\'-单引号\"-双引号\\-反斜杠\xxx-采用 xxx 编码的 Latin-1 字符。\x 和 \xx 均为合法形式，但可能引起混淆。\uxxxx-采用十六进制编码xxxx的Unicode字符。Character 类包含一些可用来处理 char 变量的 static 方法，这些方法包括 isDigit()、isLetter()、isWhitespace()和toUpperCase()。char 值没有符号。 class class关键字用来声明新的Java类，该类是相关变量和/或方法的集合。类是面向对象的程序设计方法的基本构造单位。类通常代表某种实际实体，如几何形状或人。类是对象的模板。每个对象都是类的一个实例。要使用类，通常使用new操作符将类的对象实例化，然后调用类的方法来访问类的功能。 示例 1234567891011121314151617public class Rectangle &#123; float width; float height; public Rectangle(float w, float h) &#123; width = w; height = h; &#125; public float getWidth() &#123; return width; &#125; public float getHeight() &#123; return height; &#125;&#125; continue continue 关键字用来跳转到 for、while 或 do 循环的下一个迭代。 示例 12345678for(i = 0; i &lt; max; i++) &#123; &lt;statements&gt;if(&lt;done with this iteration&gt;) &#123; continue;&#125; &lt;statements&gt;&#125; default default 关键字用来标记 switch 语句中的默认分支。 示例 123456789101112131415161718int arg = &lt;some value&gt;;switch(arg) &#123; case1: &lt;statements&gt; break; case2: &lt;statements&gt; break; default: &lt;statements&gt; break;&#125;-注释-default 块没有隐式结束点。break 语句通常在每个 case 或 default 块的末尾使用，以便在完成块时退出 switch 语句。如果没有 default 语句，其参数与任何 case 块都不匹配的 switch 语句将不执行任何操作。 do do 关键字用于指定一个在每次迭代结束时检查其条件的循环。 示例 12345678do &#123; &lt;statements&gt;&#125;while(!found);-注释-do 循环体至少执行一次。条件表达式后面必须有分号。 double double 是 Java 原始类型。 double 变量可以存储双精度浮点值。 示例 1234567double ratio = .01;double diameter = 6.15;double height = 1.35E03;//1.35*103或1350.0double height = 1e-2;//1.0*10-2或0.01-注释-由于浮点数据类型是实际数值的近似值，因此，一般不要对浮点数值进行是否相等的比较。Java 浮点数值可代表无穷大和 NaN（非数值）。Double 包装对象类用来定义常量 MIN_VALUE、MAX_VALUE、NEGATIVE_INFINITY、POSITIVE_INFINITY 和 NaN。 else else 关键字总是在 if-else 语句中与 if 关键字结合使用。else 子句是可选的，如果 if 条件为 false，则执行该子句。 示例 12345if(condition) &#123; &lt;statements&gt;&#125; else &#123; &lt;statements&gt;&#125; extends extends 关键字用在 class 或 interface 声明中，用于指示所声明的类或接口是其名称后跟有 extends关键字的类或接口的子类。 示例 123456public class Rectangle extends Polygon &#123;&#125;-示例-在上例中，Rectangle 类继承 Polygon 类的所有 public 和 protected 变量和方法。Rectangle 类可以重写 Polygon 类的任何非 final 方法。一个类只能扩展一个其他类。 false false 关键字代表 boolean 变量的两个合法值之一。 示例 1boolean is Complete = false; final final 关键字可以应用于类，以指示不能扩展该类（不能有子类）。final 关键字可以应用于方法，以指示不能重写任何子类中的方法。 示例 123456789101112public final class MyFinalClass &#123;&#125;public class MyClass &#123; public final String myFinal Method() &#123; &lt;statements&gt; &#125;&#125;-注释-一个类不能同时是 abstract 又是 final。abstract 意味着必须扩展类，final 意味着不能扩展类。一个方法不能同时是 abstract 又是 final。abstract 意味着必须重写方法，final 意味着不能重写方法。 finally finally 关键字用来定义始终在 try-catch-finally 语句中执行的块。finally 块通常包含清理代码，用在部分执行 try 块后恢复正常运行。 示例 12345678910try &#123; &lt;可能引发异常的块&gt;&#125; catch (&lt;java.lang.Exception或子类&gt;e) &#123; &lt;处理异常e的代码&gt;&#125; finally &#123; &lt;有异常或无异常情况下都执行的语句&gt;&#125;-注释-开始和结束标记 &#123; 和 &#125; 是 finally 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。每个 try 块都必须至少有一个 catch 或 finally 子句。如果执行 try 块的任何部分，不论是否出现异常，也不论 try 或 catc h块是否包含 return、continue 或 break 语句，都一定会执行 finally 块中的代码。如果不出现异常，控件将跳过try块，进入finally块。如果在执行try块期间出现异常，并且相应的catch块包含 break、continue 或 return 语句，控件将首先穿过 finally 块，之后再执行 break、continue 或 return。 float float 是Java原始类型。 float 变量可以存储单精度浮点值。 示例 1234567float ratio = .01;float diameter = 6.15;float height = 1.35E03;// 1.35*103 或 1350.0float height = 1e-2;// 1.0*10-2 或 0.01-注释-使用此关键字时应遵循下列规则：Java 中的浮点文字始终默认为双精度。要指定单精度文字值，应在数值后加上 f 或 F，如 0.01f。由于浮点数据类型是实际数值的近似值，因此，一般不要对浮点数值进行是否相等的比较。Java 浮点数值可代表无穷大和 NaN（非数值）。Float 包装对象类用来定义常量MIN_VALUE、MAX_VALUE、NEGATIVE_INFINITY、POSITIVE_INFINITY 和 NaN。 for for 关键字用于指定一个在每次迭代结束前检查其条件的循环。 示例 12345678int i = 0;for(i = 0; i &lt; max; i++) &#123; &lt;statements&gt;&#125;-注释-for 语句的形式为 for (initialize ; condition ; increment)。控件流进入 for 语句时，将执行一次 initialize 语句。每次执行循环体之前将计算 condition 的结果。如果 condition 为 true ，则执行循环体。每次执行循环体之后，在计算下一个迭代的 condition 之前，将执行 increment 语句。 if if 关键字指示有条件地执行代码块。条件的计算结果必须是布尔值。 示例 123456789101112if (condition) &#123; &lt;statements&gt;&#125;if (condition) &#123; &lt;statements&gt;&#125; else &#123; &lt;statements&gt;&#125;-注释-if 语句可以有可选的 else 子句，该子句包含条件为 false 时将执行的代码。包含 boolean 操作数的表达式只能包含 boolean 操作数。 implements implements 关键字在 class 声明中使用，以指示所声明的类提供了在 implements 关键字后面的名称所指定的接口中所声明的所有方法的实现。 示例 123456public class Truck implements IVehicle &#123;&#125;-注释-在上例中，Truck 类必须提供在 IVehicle 接口中所声明的所有方法的实现。否则，Truck 类将是独立的；它可以声明其他方法和变量，并扩展另一个类。一个类可以实现多个接口。 import import 关键字使一个包中的一个或所有类在当前 Java 源文件中可见。可以不使用完全限定的类名来引用导入的类。 示例 12345import java.io.File;import java.net.*;-注释-当多个包包含同名的类时，许多 Java 程序员只使用特定的 import 语句（没有 “*”）来避免不确定性。 instanceof instanceof 关键字用来确定对象所属的类。 示例 123456if (node instanceof TreeNode) &#123; &lt;statements&gt;&#125;-注释-在上例中，如果 node 是 TreeNode 类的实例，或者是 TreeNode 的子类的实例，则 instanceof 表达式的值将为 true。 int int 是 Java 原始类型。 int 变量可以存储 32 位的整数值。 示例 123456int number = 5;int octalNumber = 0377;int hexNumber = 0xff;-注释-Integer 类是 int 原始类型的包装对象类。它定义代表此类型的值的范围的 MIN_VALUE 和 MAX_VALUE 常量。Java 中的所有整数值都是 32 位的 int 值，除非值后面有 l或 L（如 235L），这表示该值应解释为 long。 interface interface 关键字用来声明新的 Java 接口，接口是方法的集合。接口是 Java 语言的一项强大功能。任何类都可声明它实现一个或多个接口，这意味着它实现了在这些接口中所定义的所有方法。 示例 12345678public interface IPolygon &#123; public float getArea(); public int getNumberOfSides(); public int getCircumference();&#125;-注释-实现了接口的任何类都必须提供在该接口中的所有方法的实现。一个类可以实现多个接口。 long long 是 Java 原始类型。long 变量可以存储 64 位的带符号整数。 示例 1234567long number = 5;long anotherNumber = 34590L;long octalNumber = 0377;long hexNumber = 0xffl;-注释-Long 类是 long 原始类型的包装对象类。它定义代表此类型的值的范围的 MIN_VALUE 和 MAX_VALUE 常量。Java 中的所有整数值都是 32 位的 int 值，除非值后面有 l 或 L（如 235L），这表示该值应解释为 long。 native native 关键字可以应用于方法，以指示该方法是用 Java 以外的语言实现的。 示例 1234native String getProcessorType();-注释-Native 方法不在此文档的讨论范围内。 new new 关键字用于创建类的新实例。 示例 123456String sName = new String();Float fVal = new Float(0.15);-注释-new 关键字后面的参数必须是类名，并且类名的后面必须是一组构造方法参数（必须带括号）。参数集合必须与类的构造方法的签名匹配。= 左侧的变量的类型必须与要实例化的类或接口具有赋值兼容关系。 null null 是 Java 的保留字，表示无值。 示例 123456789101112Integer i;i = null;String s;if (s != null) &#123; &lt;statements&gt;&#125;-注释-将 null 赋给非原始变量相当于释放该变量先前所引用的对象。不能将 null 赋给原始类型 （byte、short、int、long、char、float、double、boolean）变量。 package package 关键字指定在 Java 源文件中声明的类所驻留的 Java 包。 示例 12345678package com.mycompany;public class MyClass &#123;&#125;-注释-package 语句（如果出现）必须是 Java 源文件中的第一个非-注释-性文本。在上面的-示例-中，MyClass 类的完全限定类名是 com.mycompany.MyClass。如果 Java 源文件不包含 package 语句，在该文件中定义的类将位于“默认包”中。请注意，不能从非默认包中的类引用默认包中的类。 private private 关键字是访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。 示例 123456789101112131415public class MyPublicClass &#123; private class MyPrivateClass &#123; &#125; private int i; private String myMethod() &#123; &lt;statements&gt; &#125;&#125;-注释-只能在声明 private（内部）类、方法或字段的类中引用这些类、方法或字段。在类的外部或者对于子类而言，它们是不可见的。所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。 protected protected 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。 示例 123456789101112131415public class MyPublicClass &#123; protected class MyPrivateClass &#123; &#125; protected int i; protected String myMethod() &#123; &lt;statements&gt; &#125;&#125;-注释-可以在声明 protected 类、方法或字段的类、同一个包中的其他任何类以及任何子类（无论子类是在哪个包中声明的）中引用这些类、方法或字段。所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员 public public 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。 示例 123456789101112131415public class MyPublicClass &#123; public class MyPrivateClass &#123; &#125; public int i; public String myMethod() &#123; &lt;statements&gt; &#125;&#125;-注释-可能只会在其他任何类或包中引用 public 类、方法或字段。所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。 return return 关键字会导致方法返回到调用它的方法，从而传递与返回方法的返回类型匹配的值。 示例 123456789101112131415161718public void myVoidMethod() &#123; &lt;statements&gt; return;&#125;public String myStringMethod() &#123; String s = "myresponse"; returns;&#125;public int myIntMethod()&#123; int i = 5; return(i);&#125;-注释-如果方法具有非 void 的返回类型，return 语句必须具有相同或兼容类型的参数。返回值两侧的括号是可选的。 short short 是 Java 原始类型。short 变量可以存储 16 位带符号的整数。 示例 12345678short number = 5;short octalNumber = 0077;short hexNumber = 0xff;-注释-Short 类是 short 原始类型的包装对象类。它定义代表此类型的值的范围的 MIN_VALUE 和 MAX_VALUE 常量。Java 中的所有整数值都是 32 位的 int 值，除非值后面有 l 或 L（如 235L），这表示该值应解释为 long。 static static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）。 示例 1234567891011121314151617181920public class MyPublicClass &#123; public final static int MAX_OBJECTS = 100; static int_numObjects = 0; static class MyStaticClass &#123; &#125; static int getNumObjects() &#123; &#125;&#125;-注释-通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。static（内部）类可以被其他类实例化和引用（即使它是顶级类）。在上面的-示例-中，另一个类中的代码可以实例化 MyStaticClass 类，方法是用包含它的类名来限定其名称，如 MyClass.MyStaticClass。static 字段（类的成员变量）在类的所有实例中只存在一次。可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。在上面的示例中，MyClass 类外部的代码以MyClass.getNumObjects() 的形式调用 getNumObjects()static 方法。模式：public final static &lt;type&gt;varName = &lt;value&gt;;通常用于声明可以在类的外部使用的类常量。在引用这样的类常量时需要用类名加以限定。在上面的-示例-中，另一个类可以用 MyClass.MAX_OBJECTS 形式来引用 MAX_OBJECTS 常量。 super super 关键字用于引用使用该关键字的类的超类。 示例 12345678910111213public class MyClass &#123; public MyClass(Stringarg) &#123; super(arg); &#125; public String myStringMethod() &#123; return super.other String Method(); &#125;&#125;-注释-作为独立语句出现的 super 表示调用超类的构造方法。super.&lt;methodName&gt;() 表示调用超类的方法。只有在如下情况中才需要采用这种用法：要调用在该类中被重写的方法，以便指定应当调用在超类中的该方法。 switch switch 语句用于基于某个表达式选择执行多个代码块中的某一个。 示例 1234567891011121314151617181920212223242526272829303132333435363738int arg = &lt;some value&gt;;switch(arg) &#123; case1: &lt;statements&gt; break; case2: &lt;statements&gt; break; default: &lt;statements&gt; break;&#125;char arg = &lt;some value&gt;;switch(arg) &#123; case'y': case'Y': &lt;statements&gt; break; case'n': case'N': &lt;statements&gt; break; default: &lt;statements&gt; break;&#125;-注释-switch 条件的计算结果必须等于 byte、char、short 或 int，jdk1.7 后可以是 String 类型。case 块没有隐式结束点。break 语句通常在每个 case 块末尾使用，用于退出 switch 语句。如果没有 break 语句，执行流将进入所有后面的 case 和 / 或 default 块。 synchronized synchronized 关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。 示例 123456789101112131415161718192021222324public class MyClass &#123; public synchronized static String mySyncStaticMethod() &#123; &#125; public synchronized String mySyncMethod() &#123; &#125;&#125;public class MyOtherClass &#123; Object someObj; public String myMethod() &#123; &lt;statements&gt; synchronized(someObj) &#123; &lt;statement saffectingsomeObj&gt; &#125; &#125;&#125;-注释-synchronized 关键字可防止代码的关键代码段一次被多个线程执行。如果应用于静态方法（如上例中的 MySyncStaticMethod），那么，当该方法一次由一个线程执行时，整个类将被锁定。如果应用于实例方法（如上例中的 MySyncMethod ），那么，当该方法一次由一个线程访问时，该实例将被锁定。如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。 this this 关键字用于引用当前实例。 示例 12345678910public class MyClass &#123; int number; public MyClass(intnumber) &#123; this.number = number; &#125;&#125;-注释-当引用可能不明确时，可以使用 this 关键字来引用当前的实例。在上面的-示例-中，构造方法参数number 与类的成员变量同名。this.number 明确表示 MyClass 的该实例的 number 成员变量。 throw throw 关键字用于引发异常。 示例 123456789101112131415import java.io.IOException;public class MyClass &#123; public method readFile(Stringfilename)throws IO Exception &#123; &lt;statements&gt; if (error) &#123; throw new IO Exception("errorreadingfile"); &#125; &#125;&#125;-注释-throw 语句将 java.lang.Throwable 作为参数。Throwable 在调用栈中向上传播，直到被适当的 catch 块捕获。引发非 RuntimeException 异常的任何方法还必须在方法声明中使用 throws 修饰符来声明它引发的异常。 throws throws 关键字可以应用于方法，以便指出方法引发了特定类型的异常。 示例 123456789101112131415import java.io.IOException;public class MyClass &#123; public method readFile(Stringfilename)throwsIOException &#123; &lt;statements&gt; if (error) &#123; throw new IO Exception("errorreadingfile"); &#125; &#125;&#125;-注释-throws 关键字将逗号分隔的 java.lang.Throwables 列表作为参数。引发非 RuntimeException异 常的任何方法还必须在方法声明中使用 throws 修饰符来声明它引发的异常。要在 try-catch 块中包含带 throws 子句的方法的调用，必须提供该方法的调用者。 transient transient 关键字可以应用于类的成员变量，以便指出该成员变量不应在包含它的类实例已序列化时被序列化。 示例 123public class MyClass &#123; private transient String password;&#125; try try 关键字用于包含可能引发异常的语句块。 示例 123456789101112131415161718192021222324try &#123; &lt;可能引发异常的块&gt;&#125; catch (&lt;java.lang.Exception或子类&gt;e) &#123; &lt;处理异常e的代码&gt;&#125;try &#123; &lt;可能引发其他异常的块&gt;&#125; catch (FooExceptione) &#123; &lt;处理FooExceptione的代码&gt;&#125; catch (BarExceptione) &#123; &lt;处理BarExceptione的代码&gt;&#125;try &#123; &lt;可能引发异常的块&gt;&#125; catch (&lt;java.lang.Exception或子类&gt;e) &#123; &lt;处理异常e的代码&gt;&#125; finally &#123; &lt;有异常或无异常情况下都执行的语句&gt;&#125;-注释-每个 try 块都必须至少有一个 catch 或 finally 子句。如果某个特定异常类未被任何 catch 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 try 块。如果任何封闭 try 块都未捕获到异常，Java 解释器将退出，并显示错误消息和堆栈跟踪信息。 true true 关键字表示 boolean 变量的两个合法值中的一个。 示例 1boolean Complete = true; void void 关键字表示 null 类型。 示例 123456789public class MyClass &#123; public void do Something() &#123; &lt;statements&gt; return; &#125;&#125;-注释-void 可以用作方法的返回类型，以指示该方法不返回值。 volatile volatile 关键字用于表示可以被多个线程异步修改的成员变量。 注意：volatile 关键字在许多 Java 虚拟机中都没有实现。 示例 123456public class MyClass &#123; volatile int shared Value;&#125;-注释-volatile 的目标用途是为了确保所有线程所看到的指定变量的值都是相同的。 while while 关键字用于指定一个只要条件为真就会重复的循环。 示例 123while (!found) &#123; &lt;statements&gt;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>关键字</category>
      </categories>
      <tags>
        <tag>java 关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 正则表达式整理]]></title>
    <url>%2F2019%2F09%2F28%2FJava%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java 正则表达式Java 正则表达式简单介绍 英文句点符号：匹配单个任意字符。 1eg: 表达式：t.o 可以匹配：tno，t#o，teo 等等。不可以匹配：tnno，to，Tno，t 正 o 等。 方括号：只有方括号里面指定的字符才参与匹配，也只能匹配单个字符。 1eg: 表达式：t[abcd]n 只可以匹配：tan，tbn，tcn，tdn。不可以匹配：thn，tabn，tn 等。 | 符号。相当与“或”，可以匹配指定的字符，但是也只能选择其中一项进行匹配。 12eg：表达式：t(a|b|c|dd)n 只可以匹配：tan，tbn，tcn，tddn。不可以匹配taan，tn，tabcn 表示匹配次数的符号 符号 次数 * 0 次或者多次 + 1 次或者多次 ? 0 次或者 1 次 {n} 恰好 n 次 {m, n} 从 m 到 n 次 12345&#123;n， &#125; 表示至少 N 次。eg：表达式：[0—9]&#123; 3 &#125; \— [0-9]&#123; 2 &#125; \— [0-9]&#123; 3 &#125; 的匹配格式为：999—99—999因为 “—” 符号在正则表达式中有特殊的含义，它表示一个范围，所以在前面加转义字符 “\”。 ^ 符号：表示否 ^ 符号被称为 “否” 符号，如果用在方括号内，”^” 表示不想匹配的字符。 12eg：表达式：[^x] 第一个字符不能是 x 圆括号，和空白符号 12“\s” 是空白符号，只可以匹配一个空格、制表符、回车符、换页符，不可以匹配自己输入的多个空格。（）是分组号，可以用 ORO API 提取处出值，后面将详细讨论。 正则表达式的一些快捷符号 123456\d 表示 [0—9]， \D 表示 [^0—9]， \w 表示 [0—9A—Z_a—z]，\W 表示 [^0—9A—Z_a—z]， \s 表示 [\t\n\r\f], \S 表示 [^\t\n\r\f] 一些常用的正则表达式： 1234Java：(([a-z]|_)(\\w*))&#123;6,20&#125; 匹配以字母或下划线开头，字母数字下划线结尾的字符串JavaScript：/^(\-?)(\d+)$/ 匹配数字。/^\w+$/ 匹配字母数字下划线。.+ 一个或多个字符/0 第一次匹配的字符串 Java 类中使用正则表达式： 123456789eg1：Pattern p = Pattern.compile("t.n");Matcher m = p.matcher(“ton”);if(m.matches())&#123; return true;&#125; eg2：boolean bool = Pattern.matches (“t.n”,”ton”);如果一个正则表达式要重复利用，用第一种，如果只匹配一次，第二种是最佳选择。 反斜线字符（‘\’）用于转义字符，同时还可以引用非转义字符（不包括非转义字母） 因此 ‘\’ 表示‘\’，‘{’ 表示{。 但是 ‘\y’ 就是错的，因为在不表示转义构造的 任何字母字符前 使用反斜线都是错误的。 根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义 或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。例如，当解释为正则表达式时，字符串字面值 “\b” 与单个退格字符匹配，而 “\b” 与单词边界匹配。字符串字面值 “(hello)“ 是非法的，将导致编译时错误；要与字符串 (hello) 匹配，必须使用字符串字面值 “\(hello\)”。 注意：”\b” 是一个字符而 “[\b]” 是两个字符 Pattern 类 8 种模式：比如启用多行模式，启用 unix 模式等， 1eg int CASE_INSENSITIVE 表示启用不区分大小写的模式。 - 4 个静态方法 两个单例模式构造器： - Pattern compile（String regex）； - Pattern compile（String regex, int flags）flags 为八种模式的一种 12345678910111213141516eg1：Pattern p = Pattern.compile("[a-z]\\s[a-z]");Matcher m = p.matcher("b c");if(m.matches()) Sysout(1111);else Sysout(2222); 输出结果为 1111； 一个匹配方法，一个返回 String 的字面值模式方法：// input 与 regex 匹配返回 true。boolean matches(String regex,CharSequence input);String quote(String s); // 返回指定 String 的字面值。eg2：boolean bool = Pattern.matches("[a-z] [a-z]",”b c”); // 结果为 trueSysout(Pattern.quote(“a_#/tb”)); // 输出结果为 “\Qa_# b”\E - 6 个普通方法 - 返回此模式的匹配器：Matcher matcher（CharSequence input）; - 返回此模式的标志：int flags（）; - 返回此模式的 regex：String pattern（）; - 两个字符串切割方法： String[] split(CharSequence input); ​ String[] split(CharSequence input, int limit); limit 为返回字符串的个数，如果等于 0，返回所有拆分的字符串，如果大于拆字符串的实际个数，返回实际个数 - toString 方法： String toString（）; 1234567891011121314151617eg4：Pattern p = Pattern.compile("[,;\\s]");String str = "wo,ai;ni haha";String[] strs = p.split(str);for(String s : strs)&#123; Sysout(s);// 输出 “wo” “ai” “ni” “haha”&#125;strs = p.split(str,2)for(String s : strs)&#123; Sysout(s); // 输出 “wo” “ai;ni haha”&#125;Strs = p.split(str,0)for(String s : strs)&#123; Sysout(s); // 输出 “wo” “ai” “ni” “haha”&#125;常用正则表达式 “^\d+$” //非负整数（正整数 + 0） “^[0-9]*[1-9][0-9]*$” //正整数 “^((-\d+)|(0+))$” //非正整数（负整数 + 0） “^-[0-9]*[1-9][0-9]*$” //负整数 “^-?\d+$” //整数 “^\d+(.\d+)?$” //非负浮点数（正浮点数 + 0） “^(([0-9]+.[0-9]*[1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]*))$” //正浮点数 “^((-\d+(.\d+)?)|(0+(.0+)?))$” //非正浮点数（负浮点数 + 0） “^(-(([0-9]+.[0-9]*[1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]*)))$” //负浮点数 “^(-?\d+)(.\d+)?$” //浮点数 “^[A-Za-z]+$” //由26个英文字母组成的字符串 “^[A-Z]+$” //由26个英文字母的大写组成的字符串 “^[a-z]+$” //由26个英文字母的小写组成的字符串 “^[A-Za-z0-9]+$” //由数字和26个英文字母组成的字符串 “^\w+$” //由数字、26个英文字母或者下划线组成的字符串 “^[\w-]+(.[\w-]+)@[\w-]+(.[\w-]+)+$” //email地址 “^[a-zA-z]+://(\w+(-\w+))(.(\w+(-\w+)))(?\S)?$” //url /^(d{2}|d{4})-((0([1-9]{1}))|(1[1|2]))-((0-2)|(3[0|1]))$/ // 年-月-日 /^((0([1-9]{1}))|(1[1|2]))/((0-2)|(3[0|1]))/(d{2}|d{4})$/ // 月/日/年 “^([w-.]+)@(([[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.)|(([w-]+.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(]?)$” //Emil /^((+?[0-9]{2,4}-[0-9]{3,4}-)|([0-9]{3,4}-))?([0-9]{7,8})(-[0-9]+)?$/ //电话号码 “^(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5])$” //IP地址 匹配中文字符的正则表达式： [\u4e00-\u9fa5] 匹配双字节字符(包括汉字在内)：[^\x00-\xff] 匹配空行的正则表达式：\n[\s| ]\r 匹配HTML标记的正则表达式：/&lt;(.)&gt;.&lt;/\1&gt;|&lt;(.) /&gt;/ 匹配首尾空格的正则表达式：(^\s)|(\s$) 匹配 Email 地址的正则表达式：\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+) 匹配网址 URL 的正则表达式：^[a-zA-z]+://(\w+(-\w+))(\.(\w+(-\w+)))(\?\S)?$ 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 匹配国内电话号码：(\d{3}-|\d{4}-)?(\d{8}|\d{7})? 匹配腾讯 QQ 号：^[1-9]*[1-9][0-9]*$ 元字符及其在正则表达式上下文中的行为： \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个后向引用、或一个八进制转义符。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的Multiline 属性，^ 也匹配 ’\n’ 或 ’\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了 RegExp 对象的Multiline 属性，$ 也匹配 ’\n’ 或 ’\r’ 之前的位置。 *匹配前面的子表达式零次或多次。 +匹配前面的子表达式一次或多次。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。? 等价于 {0,1}。 {n} n 是一个非负整数，匹配确定的 n 次。 {n,} n 是一个非负整数，至少匹配 n 次。 {n,m} m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。 . 匹配除 “\n” 之外的任何单个字符。要匹配包括 ’\n’ 在内的任何字符，请使用象 ’[.\n]’ 的模式。 (pattern) 匹配 pattern 并获取这一匹配。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。 (?=pattern) 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。 (?!pattern) 负向预查，与 (?=pattern) 作用相反 x|y 匹配 x 或 y。 [xyz] 字符集合。 [^xyz] 负值字符集合。 [a-z] 字符范围，匹配指定范围内的任意字符。 [^a-z] 负值字符范围，匹配任何不在指定范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。 \B 匹配非单词边界。 \cx 匹配由x指明的控制字符。 \d 匹配一个数字字符。等价于 [0-9]。 \D 匹配一个非数字字符。等价于[^0-9]。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 \r 匹配一个回车符。等价于 \x0d 和 \cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 \w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。_ \W 匹配任何非单词字符。等价于 [^A-Za-z0-9_]。 \xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。 \num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。 \n 标识一个八进制转义值或一个后向引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为后向引用。否则，如果 n 为八进制数字 ( 0-7 )，则 n 为一个八进制转义值。 \nm 标识一个八进制转义值或一个后向引用。如果 \nm 之前至少有 is preceded by at least nm 个获取得子表达式，则 nm 为后向引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的后向引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 ( 0-7 )，则 \nm 将匹配八进制转义值 nm。 \nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \un 匹配 n，其中 n 是一个用四个十六进制数字表示的Unicode字符。 匹配中文字符的正则表达式： [u4e00-u9fa5] 匹配双字节字符(包括汉字在内)：[^x00-xff] 匹配空行的正则表达式：n[s| ]r 匹配HTML标记的正则表达式：/&lt;(.)&gt;.&lt;/1&gt;|&lt;(.) /&gt;/ 匹配首尾空格的正则表达式：(^s)|(s$) 匹配Email地址的正则表达式：w+([-+.]w+)@w+([-.]w+).w+([-.]w+) 匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&amp;=]*)? 利用正则表达式限制网页表单里的文本框输入内容： 用正则表达式限制只能输入中文：onkeyup=”value=value.replace(/[^u4E00-u9FA5]/g,’’)” onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^u4E00-u9FA5]/g,’’))” 用正则表达式限制只能输入全角字符： onkeyup=”value=value.replace(/[^uFF00-uFFFF]/g,’’)” onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^uFF00-uFFFF]/g,’’))” 用正则表达式限制只能输入数字：onkeyup=”value=value.replace(/[^d]/g,’’) “onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^d]/g,’’))” 用正则表达式限制只能输入数字和英文：onkeyup=”value=value.replace(/[W]/g,’’) “onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^d]/g,’’))” 整理： 匹配中文字符的正则表达式： [\u4e00-\u9fa5] 匹配双字节字符 ( 包括汉字在内 ) ：[^\x00-\xff] 匹配空行的正则表达式：\n[\s| ]\r 匹配 HTML 标记的正则表达式：/&lt;(.)&gt;.&lt;/\1&gt;|&lt;(.) /&gt;/ 匹配首尾空格的正则表达式：(^\s)|(\s$) 匹配 IP 地址的正则表达式：/(\d+).(\d+).(\d+).(\d+)/g // 匹配 Email 地址的正则表达式：\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+) 匹配网址 URL 的正则表达式：http://(/[\w-]+.)+[\w-]+(/[\w- ./?%&amp;=])? SQL 语句：^(select|drop|delete|create|update|insert).*$ 非负整数：^\d+$ 正整数：^[0-9]*[1-9][0-9]*$ 非正整数：^((-\d+)|(0+))$ 负整数：^-[0-9]*[1-9][0-9]*$ 整数：^-?\d+$ 非负浮点数：^\d+(.\d+)?$ 正浮点数：^((0-9)+.[0-9]*[1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]*))$ 非正浮点数：^((-\d+.\d+)?)|(0+(.0+)?))$ 负浮点数：^(-((正浮点数正则式)))$ 英文字符串：^[A-Za-z]+$ 英文大写串：^[A-Z]+$ 英文小写串：^[a-z]+$ 英文字符数字串：^[A-Za-z0-9]+$ 英数字加下划线串：^\w+$ E-mail 地址：^[\w-]+(.[\w-]+)@[\w-]+(.[\w-]+)+$ URL：^[a-zA-Z]+://(\w+(-\w+))(.(\w+(-\w+)))(?\s)?$ 或 ^http://[A-Za-z0-9]+.[A-Za-z0-9]+[/=?%-&amp;_~`@[]&#39;:+!]([^&lt;&gt;&quot;&quot;])$ 邮政编码：^[1-9]\d{5}$ 中文：^[\u0391-\uFFE5]+$ 电话号码：^(((\d{2,3}))|(\d{3}-))?((0\d{2,3})|0\d{2,3}-)?[1-9]\d{6,7}(-\d{1,4})?$ 手机号码：^(((\d{2,3}))|(\d{3}-))?13\d{9}$ 双字节字符(包括汉字在内)：^\x00-\xff 匹配首尾空格：(^\s)|(\s$)（像vbscript那样的trim函数） 匹配 HTML 标记：&lt;(.)&gt;.&lt;/\1&gt;|&lt;(.) /&gt; 匹配空行：\n[\s| ]*\r 提取信息中的网络链接：(h|H)(r|R)(e|E)(f|F) = *(‘|”)?(\w|\|/|.)+(‘|”| *|&gt;)? 提取信息中的邮件地址：\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)* 提取信息中的图片链接：(s|S)(r|R)(c|C) *= *(‘|”)?(\w|\|/|.)+(‘|”| *|&gt;)? 提取信息中的 IP 地址：(\d+).(\d+).(\d+).(\d+) 提取信息中的中国手机号码：(86)013\d{9} 提取信息中的中国固定电话号码：((\d{3,4})|\d{3,4}-|\s)?\d{8} 提取信息中的中国电话号码（包括移动和固定电话）：((\d{3,4})|\d{3,4}-|\s)?\d{7,14} 提取信息中的中国邮政编码：[1-9]{1}(\d+){5} 提取信息中的浮点数（ 即小数 ）：(-?\d).?\d+ 提取信息中的任何数字 ：(-?\d*)(.\d+)? IP ：(\d+).(\d+).(\d+).(\d+) 电话区号：/^0\d{2,3}$/ 腾讯 QQ 号：^[1-9]*[1-9][0-9]*$ 帐号 ( 字母开头，允许 5-16 字节，允许字母数字下划线 ) ：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 中文、英文、数字及下划线：^[\u4e00-\u9fa5_a-zA-Z0-9]+$]]></content>
      <categories>
        <category>Java</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 函数]]></title>
    <url>%2F2019%2F08%2F22%2FPython%20%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[定义：函数定义使⽤ def 关键字，函数命名全部⼩写，可由下划线连接各个单词，一般格式如下 12345678def 函数名（参数列表): 函数体eg：&gt;&gt;&gt; def hello(x, y): # 定义一个函数名为hello的函数，有两个参数：x 和 y print(‘hello’)&gt;&gt;&gt; hello() # 调用函数 参数 必传参数：必须以正确的顺序传⼊参数。 12345&gt;&gt;&gt; def hello1(x, y): # 定义一个函数名为hello1的函数，有两个参数 x 和 y print(x, y)&gt;&gt;&gt; hello1('必传', '参数')必传 参数 默认参数：给参数添加默认值，默认参数可不传。 1234567891011121314&gt;&gt;&gt; def hello2(x, y, z=8, name='simplation'): # 定义一个含有四个参数的函数，其中两个是有默认参数的 print(x, y, z, name)&gt;&gt;&gt; hello2(666, 999) # 不传入默认参数，会直接将原来的参数打印出来666 999 8 simplation&gt;&gt;&gt; hello2(666, 999, 888) # 传递默认参数，会将新的参数打印出来666 999 888 simplation&gt;&gt;&gt; hello2(666, 999, 888, 'Simplation’) 666 999 888 Simplation&gt;&gt;&gt; hello2(666, 999, name='sim’) # 不按顺序提供默认参数666 999 8 sim 注意： 必传参数必须在前，默认参数在后，否则 Python 解释器会报错； 不按顺序提供默认参数，需要把参数名写上； 可变参数：参数个数不定，在参数前⾯加了⼀个 * 号，可变参数接收到的是⼀个 tuple，这样传⼊的参数个数是可变的，可以是 1 个、2 个、任意个，还可以是 0 个。 1234567891011121314151617181920&gt;&gt;&gt; def hello3(*y): # 定义一个含有可变参数y的函数 print(y)&gt;&gt;&gt; hello3(1, '2', 3, True) (1, '2', 3, True)&gt;&gt;&gt; hello3('Simplation')('Simplation’,)&gt;&gt;&gt; hello3()()&gt;&gt;&gt; def hello4(x, *y): # 定义一个含有一个参数和可变参数的函数 print(x, y)&gt;&gt;&gt; hello4(1, '2', 3.0, True)1 ('2', 3.0, True)&gt;&gt;&gt; hello4('Simplation')Simplation () 关键字参数：与可变参数类似，关键字参数个数不定，在参数前⾯加了⼀个 ** 号，关键字参数接收到的是⼀个 dict。 123456789&gt;&gt;&gt; def hello5(x, **y): # 定义一个含有关键字参数的函数 print(x, y) &gt;&gt;&gt; hello5(1024) # 调用1024 &#123;&#125;&gt;&gt;&gt; hello5(1024, name='simplation', code=520)1024 &#123;'name': 'simplation', 'code': 520&#125; 返回值：使⽤ return 语句，可以将函数作为⼀个值赋值给指定变量。 123456789101112&gt;&gt;&gt; def hello6(x): # 定义一个含有返回值的函数 return x&gt;&gt;&gt; hello6('python’) # 调用‘python'&gt;&gt;&gt; def hello7(x, y): return x, y &gt;&gt;&gt; m = hello7(666, 999) &gt;&gt;&gt; type(m) &gt;&gt;&gt; print(type(m), m) # 打印： (666, 999) 全局变量和局部变量 在函数⾥给⼀个变量赋值的时候，Python ⾃动认为这个变量是这个作⽤域的本地变量，并屏蔽作⽤域外的同名的变量，可以声明 global，表示在向⼀个全局变量赋值。 12345678# 全局变量 &gt;&gt;&gt; z = 1024 &gt;&gt;&gt; def hello8(): globals z z = 520 print('z=' + str(z)) # z=520 &gt;&gt;&gt; hello8()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 关键字整理]]></title>
    <url>%2F2019%2F08%2F22%2FPython%20%E5%85%B3%E9%94%AE%E5%AD%97%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Python 关键字 查看所有关键字 12345import keywordkeyword.kwlistresult:['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 关键字整理 关键字 含义 False 布尔属性值，一般是判断检测的属性，False 表示为假 None 一个特殊的常量，和任何其他的数据类型比较永远返回 False，None 有自己的数据类型NoneType，并且这个类型中永远只会有它一个。如果一个函数没有返回值，那解释器就默认它的返回值是None. True 布尔属性值，一般是判断检测的属性，True 表示为真 and 表示逻辑‘与’ as 单独没有意思，with….as 用来代替传统的 try…finally 语法的 assert 表示断言，用于声明某个条件为真，如果该条件不是真的，则抛出异常：AssertionError async await break 终止循环 class 定义类 continue 跳过 continue 后面循环块中的语句，继续进行下一轮循环 def 定义方法 del 用于 list 列表操作，删除一个或者连续几个元素 elif 和 if 配合使用的，if 语句中的一个分支用 elif 或者 else 表示 else 和 if 配合使用的，if 语句中的一个分支用 elif 或者 else 表示 except 和 try 一起使用，用来捕获异常 finally 出现在异常处理中，使用格式为：try…except…finally…，try 中放想要执行的语句，except 捕获异常，finally 做一些后续的工作 for for….in 一起使用：它在一序列的对象上递归，就是遍历队列中的每一项 from 导入相应的模块，用 import 或者 from…import global 定义全局变量 if if 语句用于选择分支，和 else、elif 一起使用 import 导入相应的模块，用 import 或者 from…import in 查找列表中是否包含某个元素 is Python 中的对象包含三要素：id、type、value（id 用来唯一标识一个对象，type 标识对象的类型，value 是对象的值），is 判断的是 a 对象是否就是 b 对象，是通过 id 来判断的，== 判断的是 a 对象的值是否和 b 对象的值相等，是通过 value 来判断的 lambda 匿名函数，不用想给函数起什么名字。提升了代码的简洁程度 nonlocal nonlocal 在嵌套函数中使用，用于标识嵌套函数中的变量是包含该嵌套函数的函数中的同名变量，在嵌套函数中修改变量会影响函数中的变量。 not 表示逻辑‘非’ or 表示逻辑“或” pass pass 的意思就是什么都不做 raise raise 可以显示地引发异常。一旦执行 raise 语句，后面的代码就不执行了 return 用于跳出函数，也可以在跳出的同时返回一个值 try 出现在异常处理中，使用格式为：try…except，try 中放想要执行的语句，except 捕获异常 while while 循环，允许重复执行一块语句，一般无限循环的情况下用它 with 用法和 as 一样，和 as 一起使用 yield 用起来和 return 很像，但它返回的是一个生成器。我这样说不是很生动 使用介绍]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 错误整理]]></title>
    <url>%2F2019%2F07%2F16%2FiOS%20%E9%94%99%E8%AF%AF%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app’s Info.plist file.错误描述：创建App使用网络请求的时候，Log信息如下：App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app’sInfo.plist file.新特性要求App内访问网络请求，要采用 HTTPS 协议。 解决办法： ​ 1&gt;在 Info.plist 中添加类型为 Dictionary 的 NSAppTransportSecurity ; ​ 2&gt;在 NSAppTransportSecurity 下添加 Boolean 类型的 NSAllowsArbitraryLoads 类型,值设为 YES; 2. Declaration of sysctlbyname’ must be imported from module ‘Darwin.sys.sysctl’ before it is required解决方法：缺少相应的头文件，进行导入#import 操作即可。 3. ERROR ITMS-90717: “Invalid App Store Icon. The App Store Icon in the asset catalog in ‘*.app’ can’t be transparent nor contain an alpha channel.” 解决办法：上传 AppStore 出现的图片问题，因为图片含有 alpha 通道或者透明度，直接打开图片，重新导出，去掉勾选的 Alpha 复选框，重新打包上传。 4. ERROR ITMS-4238: “Redundant Binary Upload. There already exists a binary upload with build version ‘1’ for train ‘1.0’” at SoftwareAssets/PreReleaseSoftwareAsset解决办法：上传 AppStore 版本重复问题，存在一个版本号为 1.0 的二进制文件，需要重新修改 version 和 build，建议两个保持一致。然后再进行上传操作 5. This app has crashed because it attempted to access privacy-sensitive data without a usage description. The app’s Info.plist must contain an NSPhotoLibraryAddUsageDescription key with a string value explaining to the user how the app uses this data解决办法：访问相册或者相机的操作，缺少相关的操作权限，未配置Info.plist文件。在Info.plist文件中添加KEY为：Privacy - Photo Library Additions Usage Description的字段，类型是String，后边是描述语句]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>错误整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 中 MySQL 的相关操作]]></title>
    <url>%2F2019%2F07%2F14%2FPython%20%E4%B8%AD%20MySQL%20%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Python 中 MySQL 的相关操作1、MySQL 安装 1.1、下载 MySQL ​ 官网：https://dev.mysql.com/downloads/mysql/ 选择对应版本下载即可 1.2、安装 ​ 安装步骤就不在这里赘述。 2、MySQL 数据库连接，并实现增删改查等操作​ 注意：首先需要需要进行 import 操作 2.1、创建表操作(数据库相同的表明只能创建一次，多次创建会报错) 12345678910111213141516171819202122232425262728293031323334353637import pymysql# 创建表的操作 def create_table(): # 连接数据库 db = pymysql.connect(host='localhost', user='root', password='simplation', db='test' ) sql = '''create table if not exists department ( id int NOT NULL AUTO_INCREMENT, name text, sex text, salary float, PRIMARY KEY (`id`))''' # 使用 cursor() 创建 cursor 对象 cursor = db.cursor() try: # 执行 sql 语句的操作 cursor.execute(sql) # 提交数据库的操作 db.commit() print('create db success.') except BaseException as e: # 如果发生意外，则进行回滚操作 db.rollback() print(e) finally: # 关闭游标和数据库 cursor.close() db.close() 2.2、添加数据库操作 123456789101112131415161718192021222324252627282930313233343536import pymysql# 插入数据库的操作 def insert_table(): # 连接数据库 db = pymysql.connect(host='localhost', user='root', password='simplation', db='test', charset="utf8") print('数据库连接成功.') # sql 语句 sql = 'insert into department (name, sex, salary) values(%s, %s, %s)' # 使用 cursor() 创建 cursor 对象 cursor = db.cursor() try: # 创建要插入的值 values = ('Mr.Li', '男', 9000) # 执行 sql 语句 cursor.execute(sql, values) # 提交数据库操作 db.commit() print('insert db success.') except BaseException as e: # 出现意外则进行回滚操作 db.rollback() print(e) finally: # 关闭游标和数据库 cursor.close() db.close() 2.3、修改数据库操作 12345678910111213141516171819202122232425262728293031323334353637383940import pymysql# 修改数据库的操作def update_table(): db = pymysql.connect(host='localhost', user='root', password='simplation', db='test', charset='utf8') print('数据库连接成功.') sql = 'update department set name=%s, sex=%s, salary=%s where id = 2' # 创建 cursor 对象 cursor = db.cursor() try: values = ('John', '男', 7500) # 执行 sql 语句 cursor.execute(sql, values) # 提交数据库操作 db.commit() print('update db success.') except BaseException as e: # 出现异常则进行回滚操作 db.rollback() print(e) finally: # 关闭游标和数据库 cursor.close() db.close() 2.4、查询数据库操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import pymysql# 查询数据库的操作def query_table(): db = pymysql.connect(host='localhost', user='root', password='simplation', db='test', charset='utf8') print('连接数据库成功.') sql = 'select * from department' cursor = db.cursor() try: # 执行 sql 语句 cursor.execute(sql) # 查询一条记录 result = cursor.fetchone() print('查询到的一条记录是: id=%s name=%s, sex=%s, salary=%d' % (result[0], result[1], result[2], result[3])) # 如果先⽤ fetchone()，游标是从 1 开始 # 重置游标位置，偏移量:⼤于0向后移动;⼩于0向前移动，mode默认是relative # relative:表示从当前所在的⾏开始移动; absolute:表示从第⼀⾏开始移动 cursor.scroll(0, mode='absolute') # 查询多条语句 results = cursor.fetchall() for result in results: print('查询到的记录是：id=%s, name=%s, sex=%s, salary=%s' % (result[0], result[1], result[2], result[3])) print('query db success.') except BaseException as e: # 出现异常则进行回滚操作 db.rollback() print(e) finally: # 关闭游标和数据库 cursor.close() db.close() 2.5、删除数据库操作 123456789101112131415161718192021222324252627282930313233343536import pymysql# 删除数据库的操作def delete_table(): db = pymysql.connect(host='localhost', user='root', password='simplation', db='test') print('db connect success.') sql = 'delete from department where id=%s' cursor = db.cursor() try: # 执行 sql 语句 cursor.execute(sql, 5) db.commit() print('delete db success.') except BaseException as e: # 出现异常则进行回滚操作 db.rollback() print(e) finally: # 关闭游标和数据库 cursor.close() db.close()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MySQL的相关操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 中标准数据类型]]></title>
    <url>%2F2019%2F07%2F11%2FPython%20%E4%B8%AD%E6%A0%87%E5%87%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Python 中标准数据类型标准数据类型：​ Number(数字)、String(字符串)、List(列表)、Tuple(元祖)、Dictionary(字典)、Sets(集合) Number(数字) 1.1、支持int(整数类型)、float(浮点型)、bool(布尔)、complex(复数) 123456789&gt;&gt;&gt; a = 100 # 整数类型&gt;&gt;&gt; b = 10.0 # 浮点型&gt;&gt;&gt; c = True # 布尔&gt;&gt;&gt; print(a,b,c) # 打印结果：100 10.0 True复数由实数部分和虚数部分构成，可以使用a + bj,或者complex(a, b)表示，复数的是实部a和虚部b都是浮点型 1.2、数值运算 加(+)、减(-)、乘()、除(/)、取余(%)、乘方(*) 1234567891011121314151617&gt;&gt;&gt; a = 20&gt;&gt;&gt; b = 30&gt;&gt;&gt; print(a + b) # 加 打印结果：50&gt;&gt;&gt; print(a - b) # 减 打印结果：-10&gt;&gt;&gt; print(a * b) # 乘 打印结果：600&gt;&gt;&gt; print(a / b) # 除 打印结果：.6666666666666666&gt;&gt;&gt; print(a % b) # 取余 打印结果：20&gt;&gt;&gt; print(a ** b) # 乘方 打印结果：1073741824000000000000000000000000000000注：除法(/)返回的都是浮点类型的数值，而除法 (//)返回的是整型 String(字符串)​ Python中的字符串使用’’(单引号)或者””(双引号)将字符串进行包裹起来，但是特殊字符需要使用转义字符()进行转义操作。 2.1、常用操作 12345678910111213141516171819202122232425262728293031323334353637383940414243&gt;&gt;&gt; string = 'Hello， I \'m Simplation.'&gt;&gt;&gt; print(string) # 输出操作 返回 Hello， I 'm Simplation.&gt;&gt;&gt; print(len(string)) # 打印结果：23&gt;&gt;&gt; print(string[0]) # 打印结果：H&gt;&gt;&gt; print(string[0, -1]) # 打印结果：Hello， I 'm Simplation&gt;&gt;&gt; print(string[11:22]) # 打印结果：Simplation &gt;&gt;&gt; print(string[11:]) # 打印结果：Simplation.&gt;&gt;&gt; print(string * 2) # 打印结果：Hello， I 'm Simplation.Hello， I 'm Simplation.&gt;&gt;&gt; print('everyone ' + string) #e打印结果：everyone Hello， I 'm Simplation.&gt;&gt;&gt; print('Simplation' in string) # True&gt;&gt;&gt; print(string.find('Simplation')) # 查找 返回字符串所在下标 12&gt;&gt;&gt; print(string.index('Sim')) # 12&gt;&gt;&gt; print(string.upper()) # HELLO， I 'M SIMPLATION.&gt;&gt;&gt; print(string.lower()) # hello， i 'm simplation.&gt;&gt;&gt; print('Simplation' in string) # True&gt;&gt;&gt; print(string.capitalize()) # Hello， i 'm simplation.&gt;&gt;&gt; print(string.isspace()) # False&gt;&gt;&gt; print(string.replace('Sim', ' ')) # Hello， I 'm plation.&gt;&gt;&gt; print(string.split('m')) # ["Hello， I '", ' Si', 'plation.']&gt;&gt;&gt; print(string.strip()) # 去掉字符串左右两边的空格 Hello， I 'm Simplation.&gt;&gt;&gt; print(string.rstrip()) # 去掉字符串右边的空格 Hello， I 'm Simplation.&gt;&gt;&gt; print(string.lstrip()) # 去掉字符串左边的空格Hello， I 'm Simplation. 2.2、占位符 常用占位符：%d表示那个位置是整数；%f表示那个位置是浮点数；%s表示那个位置是字符串 12345678&gt;&gt;&gt; print('Hello, %s' %'Python’) # Hello, Python&gt;&gt;&gt; print('Hello, %d%s%.2f' %(666, 'Python', 9.99)) # Hello, 666Python9.99注: 2.2.1、% 是转换开始的标志；2.2.2、如果不止一个占位符，要写在一个圆括号内，中间用逗号隔开；2.2.3、%.2f代表两位小数，不是两位后会四舍五入 2.3、字符串换行 2.3.1、三个单引号：Python中三个单引号允许一个字符串跨多行，字符串中也可以包括换行符、制表符以及其他的字符， 123456789101112&gt;&gt;&gt; s = '''相思唐代：王维红豆生南国，春来发几枝。愿君多采撷，此物最相思。'''&gt;&gt;&gt; print(s)相思唐代：王维红豆生南国，春来发几枝。愿君多采撷，此物最相思。 2.3.2、三个双引号 2.3.3、\结尾 List(列表)​ 列表是写在方括号[]中，元素用逗号,隔开,类标中的元素类型可以是不相同的 123&gt;&gt;&gt; L = [6, 9.9, 'Simplation', True, 'I\'m Simplation'] # 创建列表&gt;&gt;&gt; print(L) # [6, 9.9, 'Simplation', True, "I'm Simplation"] 3.1、访问元素 1234567891011&gt;&gt;&gt; print(L) # 打印列表，结果：[6, 9.9, 'Simplation', True, "I'm Simplation”]&gt;&gt;&gt; print(len(L)) # 打印列表的长度 结果：5&gt;&gt;&gt; print(L[1]) # 打印列表的第一个元素 结果：9.9&gt;&gt;&gt; print(L[2:4]) # 输出列表的第二个和第三个元素 结果：['Simplation', True]&gt;&gt;&gt; print(L[:4]) # 输出一个第0个到第三个元素 结果：[6, 9.9, 'Simplation', True]&gt;&gt;&gt; print(L[-1]) # 输出最后一个元素 结果：I'm Simplation 3.2、添加元素 12345678910111213141516171819202122232425262728&gt;&gt;&gt; L1 = [False]&gt;&gt;&gt; print(L + L1) # List 拼接['1024', 9.9, 'Simplation', True, "I'm Simplation", False]&gt;&gt;&gt; L.extend(L1) # 在List的末尾一次性增加一个元素&gt;&gt;&gt; print(L)['1024', 9.9, 'Simplation', True, "I'm Simplation", False]&gt;&gt;&gt; L.extend(L1) # 每执行一次extend函数，就会在列表的最后一项添加一个元素&gt;&gt;&gt; print(L)['1024', 9.9, 'Simplation', True, "I'm Simplation", False, False]&gt;&gt;&gt; L.append('进行拼接测试’) # append()方法拼接，在列表最后一项新增一个元素&gt;&gt;&gt; print(L)['1024', 9.9, 'Simplation', True, "I'm Simplation", False, False, '进行拼接测试’]&gt;&gt;&gt; L.insert(1, '不放假’) # 在列表的某个位置插入元素 &gt;&gt;&gt; print(L)['1024', '不放假', 9.9, 'Simplation', True, "I'm Simplation", False, False, '进行拼接测试'] 3.3、更新元素 123&gt;&gt;&gt; L[0] = '1024’ # 更新第0个元素的值为’1024’&gt;&gt;&gt; print(L) # 打印更新后的列表 ['1024', 9.9, 'Simplation', True, "I'm Simplation"] 3.4、删除元素 123456789101112131415161718192021222324&gt;&gt;&gt; L.pop() # pop ⽅法删除，可指定位置，默认最后⼀个"I'm Simplation”&gt;&gt;&gt; L['1024', 9.9, 'Simplation', True]&gt;&gt;&gt; L.pop(0) # pop 指定位置 、'1024'&gt;&gt;&gt; L[9.9, 'Simplation', True]&gt;&gt;&gt; del L[-1] # 删除列表最后一个元素&gt;&gt;&gt; L[9.9, 'Simplation’]&gt;&gt;&gt; L.remove(9.9) # 移除列表中某个值的第⼀个匹配项，没有会抛异常&gt;&gt;&gt; L['Simplation'] 3.5、其他 1234567891011121314&gt;&gt;&gt; print(L * 2) # 将列表的内容打印两次['1024', 9.9, 'Simplation', True, "I'm Simplation", '1024', 9.9, 'Simplation', True, "I'm Simplation”]&gt;&gt;&gt; L.reverse() # 反向列表中元&gt;&gt;&gt; print(L)&gt;&gt;&gt; L3 = L.copy() # 复制 浅拷贝操作&gt;&gt;&gt; print(L3)["I'm Simplation", True, 'Simplation', 9.9, '1024’]&gt;&gt;&gt; L3.clear() # 清空列表&gt;&gt;&gt; L3[] Tuple(元祖)​ 元组写在⼩括号 () ⾥，元素之间⽤逗号隔开，元组的元素不能修改，没有 append()，insert() 这样的⽅法。 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; s = (100, 100.0, 'Simplation', True, 'I\'am Simpaltion.', [1, 2, 3])&gt;&gt;&gt; print(s)(100, 100.0, 'Simplation', True, "I'am Simpaltion.", [1, 2, 3])&gt;&gt;&gt; print(s[0]) # 输出 list 第 1 个元素100&gt;&gt;&gt; print(s[2:5]) # 输出 lsit 下标从第 2 个到第 4个元素('Simplation', True, "I'am Simpaltion.”)&gt;&gt;&gt; print(s[2:]) # 输出 lsit 下标从第 2 个起后⾯所有元素('Simplation', True, "I'am Simpaltion.", [1, 2, 3])&gt;&gt;&gt; s1 = (1, False)&gt;&gt;&gt; print(s + s1) # list 拼接(100, 100.0, 'Simplation', True, "I'am Simpaltion.", [1, 2, 3], 1, False)&gt;&gt;&gt; print(s * 2) # 打印两次(100, 100.0, 'Simplation', True, "I'am Simpaltion.", [1, 2, 3], 100, 100.0, 'Simplation', True, "I'am Simpaltion.", [1, 2, 3])&gt;&gt;&gt; print(len(s)) # 输出 list ⻓度6注：虽然元组元素不能修改，但能把 list 当特殊元素。 Dictionary(字典)​ 字典⽤ { } 标识或者 dict() ⽅法创建字典，它是⼀个⽆序的键 (key) : 值 (value) 对集合。键 (key) 必须 使⽤不可变类型。在同⼀个字典中，键 (key) 必须是唯⼀的（不唯⼀，取最后⼀个值，不建议这样 写）。{ } 是⽤来创建⼀个空字典。 1dic = &#123;'name':'Simplation', 'site': '[http://www.baidu.com]', 'code': 1024&#125; 5.1、访问元素 123456&gt;&gt;&gt; print(dic) # 打印字典&#123;'name': 'Simplation', 'site': '[http://www.baidu.com]', 'code': 1024&#125;&gt;&gt;&gt; print(dic['site']) # 输出键为 site 的值[http://www.baidu.com[http://www.baidu.com 5.2、修改元素 123&gt;&gt;&gt; dic['code'] = 520 # 修改元素 &gt;&gt;&gt; print(dic['code']) # 打印：520&#123;'name': 'Simplation', 'site': '[http://www.baidu.com]', 'code': 520&#125; 5.3、新增元素 123&gt;&gt;&gt; dic['id'] = 1314 # 新增元素&gt;&gt;&gt; dic、&#123;'name': 'Simplation', 'site': '[http://www.baidu.com]', 'code': 520, 'id': 1314&#125; 5.4、删除元素 1234567891011&gt;&gt;&gt; dic.pop('code’) # 删除 code 键1024&gt;&gt;&gt; print(dic)&#123;'name': 'Simplation', 'site': '[http://www.baidu.com]’&#125;&gt;&gt;&gt; dic.clear() # 清空字典&gt;&gt;&gt; dic&#123;&#125; 5.5、其他 123456789101112131415161718# dict() ⽅法创建字典 d = dict(id=1024, name&gt;&gt;&gt; d = dict(id=1024, name='simplation', site='[http://www.baidu.com/]')&gt;&gt;&gt; print(d)&#123;'id': 1024, 'name': 'simplation', 'site': '[http://www.baidu.com/]'&#125;&gt;&gt;&gt; print(d.copy()) # 浅拷贝&#123;'id': 1024, 'name': 'simplation', 'site': '[http://www.baidu.com/]'&#125;&gt;&gt;&gt; dic.keys() # 打印字典中的所有key值dict_keys(['name', 'site', 'code’])&gt;&gt;&gt; dic.values() # 打印字典中所有value值dict_values(['Simplation', '[http://www.baidu.com]', 1024]) Sets(集合)​ 集合是⼀个⽆序不重复元素的序列，⽤⼤括号 { } 或者 set() 函数创建。创建⼀个空集合必须⽤ set()， 因为 { } 是⽤来创建⼀个空字典。 123&gt;&gt;&gt; s = &#123;'name', 'site', 'code', 1, 1&#125; # 创建集合&gt;&gt;&gt; print(s)&#123;1, 'name', 'site', 'code'&#125; 空值​ Python ⾥⼀个特殊的值，叫做空值，⽤ None 表示。 数据类型转换​ Python中内置的bif可以进行数据间的类型转换 1234567int(x)：将 x 转换为⼀个整数 float(x)：将 x 转换到⼀个浮点数 str(x)：将对象 x 转换为字符串 list(s)：将序列 s 转换为⼀个列表]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>基本数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome 常用插件汇总]]></title>
    <url>%2F2019%2F07%2F01%2FChrome%20%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[自做 Android 以来，成为一名 Google 的死忠粉，Google 的软件产品几乎都用过，这篇主要记录一下 Chrome 的相关扩展程序，有了这些插件，你的 Chrome 绝对堪称神器。(要有取舍，当然这里忽略内存！！！) 百度网盘助手 把网盘的下载地址导出到aria2/aria2-rpc，支持YAAW Adblock Plus 免费广告拦截程序 Augmented Steam ChroPath 生成和验证独特的选择器 Color by Fardos 从网站中选择颜色，保存颜色和渐变，获得匹配的色调和色调，并创建美丽的渐变 Dark Reader 黑色主题，适用于任何网站。关爱眼睛，就使用Dark Reader进行夜间和日间浏览 GayHub github的一个很棒的扩展程序 Infinity 新标签页(Pro) 百万用户选择的新标签页和快速拨号，自由添加网站图标，云端高清壁纸，快速访问书签、天气、笔记、待办事项、扩展管理与历史记录 JavaScript and CSS Code Beautifier 打开 .css / .js / .json 文件时，可以美化 CSS，JavaScript 和 JSON 代码。 JSONView 验证、查看、并格式化 JSON 文档 Momentum 美化 Chrome 启动页，将新标签页替换为具有待办事项，天气和灵感的个人仪表板等。 Octotree 以树形结构显示 Github 仓库的代码，省去一级一级查找 Reggy 创建随机身份并在几秒钟内注册任何网站！ Reggy还包括一个内置的表格填充物 uBlock Origin 一款高效的网络请求过滤工具，占用极低的内存和 CPU。 Web Scraper 网站数据提取工具 书签侧边栏 在浏览器视图区左侧添加固定式的, 管理所有书签的侧边栏. 二管家 一个全能的拓展管理和用户脚本管理拓展 简悦 - SimpRead 让你瞬间进入沉浸式阅读的 Chrome 扩展，类似 Safari 的阅读模式。 包含 聚焦模式和阅读模式两种 谷歌访问助手 不用多说了吧 达达划词翻译 划词翻译、生词本、吐司弹词、与扇贝同步 Vysor无需 root, 能够在 Chrome 里通过 USB 直接控制 Android 设备]]></content>
      <categories>
        <category>Chrome</category>
        <category>Browser</category>
      </categories>
      <tags>
        <tag>Chrome Extension</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 中常见问题汇总(附解决办法)]]></title>
    <url>%2F2019%2F06%2F04%2FAndroid%20%E4%B8%AD%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[本片博文主要介绍的是自己在日常工作中遇到的一些问题，在此统一做一个汇总，希望能后帮到大家。 1.Android Studio 编译项目报错：The SourceSet ‘instrumentTest’ is not recognized by the Android Gradle Plugin. 2.导入Eclipse项目报错，Error:Could not determine the class-path for interface com.android.builder.model.AndroidProject. 3.使用Retrofit进行网络请求（post）的时候，log打印日志：java.lang.IllegalArgumentException: @FieldMap parameters can only be used with form encoding. (parameter #1) 4.查看SHAR1值的方法 5.Could not find com.android.tools.build:aapt2:3.2.1-4818971. 6.AAPT2 error: check logs for details 7.java.lang.UnsatisfiedLinkError: dlopen failed: library “/system/lib64/libweibosdkcore.so” needed or dlopened by “/system/lib64/libnativeloader.so” is not accessible for the namespace “classloader-namespace” 8.java.io.IOException: proguard.ParseException: Unexpected keyword ‘com.amap.api.mapcore.xx’ 9.给项目添加 Android 10 的网络权限。 10.Android 中 String 资源文件添加空格/空白格 11.Android XListView 在刷新数据是越界问题。 12.Didn’t find class “android.support.v4.content.FileProvider” on path: 13.AndroidStudio无法连接模拟器。 14.Android java.lang.RuntimeException: Parcelable encountered IOException writing serializable object 15.Android.os.TransactionTooLargeException 异常解决 16.java.lang.IllegalArgumentException: Both dimensions must be greater than 0 二维码扫描 17.Error:Execution failed for task ‘:包路径:mergeReleaseResources’. 18.Could not get unknown property ‘jnilibs’ for source set ‘main’ of type org.gradle.api.internal.tasks.DefaultSourceSet. 19.android N 调用相机错误提示: android.os.FileUriExposedException: file:///storage/emulated/0/picture1551231656.jpg exposed beyond app through Intent.getData() 20.The number of method references in a .dex file cannot exceed 64K. 21.Android Studio中references to other resources are not supported by build-time PNG generation解决方案 22.解决”No toolchains found in the NDK toolchains folder for ABI with prefix: 23.Annotation processors must be explicitly declared now. The following dependencies on the compile classpath are found to contain annotation processor. Please add them to the annotationProcessor configuration. 24.java.util.concurrent.ExecutionException: com.android.builder.internal.aapt.v2.Aapt2Exception: Android resource compilation failed Output: E:\working space\GaoxinSafetyEnter\appclient\build\intermediates\incremental\mergeDebugResources\merged.dir\values\values.xml:932: error: inner element must either be a resource reference or empty. 25.Android TextView 显示后台返回的富文本内容 26.Android Activity 页面 Edittext 控件自动弹出软键盘的问题。（修改为使用时才弹出软键盘） 27.Could not find manifest-merger.jar (com.android.tools.build:manifest-merger:26.0.1). 28.布局报错：Error parsing XML: not well-formed (invalid token) 29.Android P 提示 java.io.IOException: Cleartext HTTP traffic to XXX not permitted 30.Android P Android java.lang.NoClassDefFoundError: Failed resolution of: Lorg/apache/commons/logging/LogFactory 31.java.lang.NoClassDefFoundError: Failed resolution of: Lokio/Buffer 32.java.lang.RuntimeException: Parcelable encountered IOException writing serializable object (name = com.example.app.moudle.CheckAgainstStandard$ListBean) 33.Android studio Could not download guava.jar 34.java.lang.IllegalArgumentException: timeout too large. 35.java.lang.SecurityException: Need to declare android.permission.REQUEST_INSTALL_PACKAGES to call this api 1.Android Studio 编译项目报错：The SourceSet ‘instrumentTest’ is not recognized by the Android Gradle Plugin. 解决办法：gradle 配置，这里的配置中 instrumentTest 已被弃用，不适用于现在的 gradle 版本。用 androidTest 替换 instrumentTest，编译运行即可。 2.导入Eclipse 项目报错，Error:Could not determine the class-path for interface com.android.builder.model.AndroidProject. 解决办法：修改自己本地安装的 gradle 版本号，然后重新编译执行。 3.使用Retrofit进行网络请求（post）的时候，log打印日志：java.lang.IllegalArgumentException: @FieldMap parameters can only be used with form encoding. (parameter #1) 解决办法：当POST请求时，@FormUrlEncoded和@Field简单的表单键值对。两个需要结合使用，否则会报错；@Query请求参数。无论是GET或POST的参数都可以用它来实现 1234正确写法： @FormUrlEncoded @POST(forgetpwd) Observable&lt;ResponseBody&gt; forget(@FieldMap Map&lt;String, String&gt; map); 4.查看SHAR1值的办法。 解决办法： (1).把apk的格式改为压缩文件，进行解压。 (2).在解压出来的文件中获取META-INF文件夹下的CERT.RSA文件。 (3).打开cmd Keytool –printcert –file 后面接文件的路径。 5.Could not find com.android.tools.build:aapt2:3.2.1-4818971. 解决方法：在项目的build.gradle文件中，新增一行google()即可解决 123456allprojects &#123; repositories &#123; jcenter() google()//新增这一行 &#125;&#125; 6.AAPT2 error: check logs for details 解决办法：构建 App 的时候，打开 Build 窗口，点击 “Toggle View” 切换到文本输出。查看log具体输出原因 7.java.lang.UnsatisfiedLinkError: dlopen failed: library “/system/lib64/libweibosdkcore.so” needed or dlopened by “/system/lib64/libnativeloader.so” is not accessible for the namespace “classloader-namespace” 解决办法：根据错误提示，缺少对应的so文件，需要ctrl+shift+n找到so，并拷贝到jniLibs文件夹下，注意对应的文件位置。重新rebuild即可。 8.java.io.IOException: proguard.ParseException: Unexpected keyword ‘com.amap.api.mapcore.xx’ 解决办法： 1.检查关键字是否错误，keep class 等 2.检查包名是否拼写错误 3.检查是否有中文字符，比如括号，点，空格，空格，空格 9.给项目添加 Android 10 的网络权限。解决办法： 1.将如下代码，添加到xml文件中 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted="true" /&gt;&lt;/network-security-config&gt; ​ 2.在application中引用xml文件即可。 10.Android 中 String 资源文件添加空格/空白格解决办法：Android 中字符串资源放置在 string.xml 文件中，并且该文件不能识别空格，但是在实际开发过程中需要用到空格，在需要设置的地方添加 &#160; 即可。 *11.Android XListView 在刷新数据是越界问题：java.lang.IndexOutOfBoundsException: Invalid index 1, size is 1 。 * 解决办法： ​ 1.不使用下拉刷新的headView, ​ 2.当adapter的数据被全部clean时,使用adapter.notifyDataSetInvalidated(); ​ 3.在加入新的数据后,使用adapter.notifyDataSetChanged(); 12.Didn’t find class “android.support.v4.content.FileProvider” on path: 解决办法： ​ 1.添加如下代码 123defaultConfig &#123; multiDexEnabled true&#125; ​ 2.在Application中重写 attachBaseContext() 方法 并初始化 MultiDex.install(this); 13.AndroidStudio无法连接模拟器。 解决办法： ​ 1.首先进入到 AndroidStudio 下的plateform-tools目录下 ​ 2.执行 adb connect 127.0.0.1：62001 ​ 3.出现 connected to 127.0.0.1:62001 则表示连接成功 *14.Android java.lang.RuntimeException: Parcelable encountered IOException writing serializable object * 解决办法： ​ 1.抛出java.io.NotSerializableException异常,抛出这个异常是因为你的对象没有实现Serializable接口，只要实现该接口就好了。 ​ 2.抛出java.lang.RuntimeException异常,抛出这个异常是因为传递的对象里面的对象也要实现Serializable接口。 15.Android.os.TransactionTooLargeException 异常解决 解决办法：Android 中进程中通过 binder 是通讯的数据载体，当序列化数据过大时，会出现该异常。 ​ 1.可以通过 EventBus 等替代方案来解决。 ​ 2.使用 getIntent().getSerializableExtra() 传递数据，数据量不宜过大。 16.java.lang.IllegalArgumentException: Both dimensions must be greater than 0 二维码扫描 解决办法：需要将 ZXApplication 添加到配置清单文件中 17.Error:Execution failed for task ‘:包路径:mergeReleaseResources’. 解决办法：本地包路径\src\main\res\values\attrs.xml: Error: Found item Attr/textColor more than one time 根据错误信息描述可以推测出 textColor 属性被多次声明, 可以去掉多余的或者是无用的信息. 18.Could not get unknown property ‘jnilibs’ for source set ‘main’ of type org.gradle.api.internal.tasks.DefaultSourceSet. 解决办法：jnilibs需要更改为：jniLibs， 添加如下代码： 12345sourceSets&#123; main&#123; jniLibs.srcDirs=['libs'] &#125;&#125; 19.android N 调用相机错误提示: android.os.FileUriExposedException: file:///storage/emulated/0/picture1551231656.jpg exposed beyond app through Intent.getData() 解决办法： ​ 1.调用相机 1234567891011121314// 启动拍照,并保存到临时文件Intent mIntent = new Intent();mIntent.setAction(MediaStore.ACTION_IMAGE_CAPTURE);int currentVersion = Build.VERSION.SDK_INT;if (currentVersion &lt; 24) &#123; mIntent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(mPictureFile)); startActivityForResult(mIntent, REQUEST_CAMERA_IMAGE);&#125; else &#123; ContentValues contentValues = new ContentValues(1); contentValues.put(MediaStore.Images.Media.DATA, mPictureFile.getAbsolutePath()); Uri uri = getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,contentValues); mIntent.putExtra(MediaStore.EXTRA_OUTPUT, uri); startActivityForResult(mIntent, REQUEST_CAMERA_IMAGE);&#125; ​ 2.获取图片 12345fileSrc = mPictureFile.getAbsolutePath();updateGallery(fileSrc);File file = new File(fileSrc);Uri uri = FileProvider.getUriForFile(this, getPackageName() + ".provider", file);FaceUtil.cropPicture(this, uri); 20.The number of method references in a .dex file cannot exceed 64K. 解决办法： ​ 1.在 dependencies 中添加如下代码 1compile 'com.android.support:multidex:1.0.1' ​ 2.在 defaultConfig 中添加如下代码 1multiDexEnabled true ​ 3.在 AndroidManifest.xml 中的 application 标签中添加 12android:name="android.support.multidex.MultiDexApplication"&gt;android:name="com.xxxx.xxxx.YourApplication"&gt; ​ 4.如果你的应用程序继承 Application , 那么你需要重写Application attachBaseContext方法 12345@Overrideprotected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this) ;&#125; 21.Android Studio中references to other resources are not supported by build-time PNG generation解决方案 解决办法：在 build.gradle 文件中添加以下代码 123defaultConfig &#123; vectorDrawables.useSupportLibrary = true&#125; 22.解决”No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android”错误 解决办法：NDK的更新记录里有下边一段话:This version of the NDK is incompatible with the Android Gradle plugin version 3.0 or older. If you see an error like toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android,```123456789 update your project file to [use plugin version 3.1 or newer]. You will also need to upgrade to Android Studio 3.1 or newer.新版本的NDK与3.0及以前旧版的Android Gradle plugin插件不兼容```javadependencies &#123; classpath &apos;com.android.tools.build:gradle:3.2.0&apos; // 修改为你拥有的版本号即可&#125; *23.Annotation processors must be explicitly declared now. The following dependencies on the compile classpath are found to contain annotation processor. Please add them to the annotationProcessor configuration. * 解决办法：在项目的 build.gradle 文件中的 android 下的 defaultConfig 中添加如下代码，然后重新编译即可。 1javaCompileOptions.annotationProcessorOptions.includeCompileClasspath = true 24.java.util.concurrent.ExecutionException: com.android.builder.internal.aapt.v2.Aapt2Exception: Android resource compilation failed Output: E:\working space\GaoxinSafetyEnter\appclient\build\intermediates\incremental\mergeDebugResources\merged.dir\values\values.xml:932: error: inner element must either be a resource reference or empty. 解决办法：找到报错的目标文件的具体位置，打开全局搜索(Ctrl + Shift + F) Scope 查找资源文件的名称，然后修改即可。 25.Android TextView 显示后台返回的富文本内容 解决办法：使用 Html.fromHtml() ​ 1.定义富文本内容 1String content = "&lt;p style=\"padding: 0px; margin: 0px; color: rgb(43, 43, 43); font-family: 微软雅黑, 宋体, serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial; text-indent: 2em;\"&gt;国家安全生产监督管理总局令&lt;\/p&gt;" ​ 2.使用 Html.fromHtml() 123CharSequence charSequence = Html.fromHtml(content);contentTxt.setText("内容:" + charSequence);contentTxt.setMovementMethod(LinkMovementMethod.getInstance()); 26.Android Activity 页面 Edittext 控件自动弹出软键盘的问题。（修改为使用时才弹出软键盘） 解决办法： ​ 1.在Edittext 控件上添加如下两个属性 12android:focusable="true"android:focusableInTouchMode="true" ​ 2.在配置清单文件中找到对应的 Activity 页面, 添加如下属性即可。 1android:windowSoftInputMode="adjustResize|stateHidden" 27.Could not find manifest-merger.jar (com.android.tools.build:manifest-merger:26.0.1). 解决办法：将 google() 和 jcenter() 换下位置，让它去 google 中下载 manifest-merger.jar 包，就可以编译通过. 28.布局报错：Error parsing XML: not well-formed (invalid token) 解决办法：首先确定布局文件编码是否为 utf-8 格式，其次是 xml 文件中不能出现 ‘&lt;’ ‘&gt;’ 等符号, 建议在代码中赋值. 29.Android P 提示 java.io.IOException: Cleartext HTTP traffic to XXX not permitted 解决办法：Android P的系统上面默认所有Http的请求都被阻止了。通过在AnroidManifestz.xml中的application显示设置： 1&lt;application android:usesCleartextTraffic="true"&gt; 30.Android P Android java.lang.NoClassDefFoundError: Failed resolution of: Lorg/apache/commons/logging/LogFactory 解决办法： ​ 1.添加 commons-logging-4.0.6 jar 到 libs 文件夹下并引用。 ​ 2.在AnroidManifest.xml中的application显示设置： 31.java.lang.NoClassDefFoundError: Failed resolution of: Lokio/Buffer 解决办法：缺少 Okio 的 Libs，添加进项目即可。 链接地址:https：//github.com/square/okio 1implementation ' com.squareup.okio：okio：2.2.2 ' 32.java.lang.RuntimeException: Parcelable encountered IOException writing serializable object (name = com.example.app.moudle.CheckAgainstStandard$ListBean) 解决办法：该实体类中存在部分类没有实现 serializable 接口，仔细检查，让所有的类都实现 serializable 接口即可。 33.Android studio Could not download guava.jar 解决办法：项目中没有用到 guava.jar 的相关东西，删除 .gradle 和 .idea 两个文件夹，重新 rebuild 即可。 34.java.lang.IllegalArgumentException: timeout too large. 解决办法：网络请求中超时时间过长导致的，一般情况下超时时间设置为 5s 就可以了。 35.java.lang.SecurityException: Need to declare android.permission.REQUEST_INSTALL_PACKAGES to call this api 解决办法：配置清单文件中缺少 REQUEST_INSTALL_PACKAGES 权限，添加即可。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android问题</tag>
        <tag>汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 HEXO 的一些常用命令]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%85%B3%E4%BA%8E%20hexo%20%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[由于电脑系统重装，之前的内容没有备份, 从2017年到2019年的内容靠自己之前整理的一些笔记还原了部分文章。不过目前已经重新将架子搭起来，准备继续搞起来！！！欢迎来到[Hexo]（https://hexo.io/）！ 这是你的第一篇文章。 有关详细信息，请查看[文档]（https://hexo.io/docs/）。 如果您在使用Hexo时遇到任何问题，可以在[故障排除]（https://hexo.io/docs/troubleshooting.html）中找到答案，或者您可以在[GitHub]（https://github.com）上找到我。/ hexojs/ HEXO/问题）。 ＃＃ 快速开始 ###创建一个新帖子 1$ hexo new“我的新帖子” 更多信息：[写作]（https://hexo.io/docs/writing.html） ###运行服务器 1$ hexo服务器 更多信息：[服务器]（https://hexo.io/docs/server.html） ###生成静态文件 1$ hexo生成 更多信息：[Generating]（https://hexo.io/docs/generating.html） ###部署到远程站点 1$ hexo deploy 更多信息：[部署]（https://hexo.io/docs/deployment.html）]]></content>
      <categories>
        <category>HEXO 的常用命令</category>
      </categories>
      <tags>
        <tag>hexo 的操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 第三方包管理工具-Pip]]></title>
    <url>%2F2018%2F05%2F28%2FPython%20%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-Pip%2F</url>
    <content type="text"><![CDATA[Pip 是Python 推荐的用于安装Python软件包的工具。首先简单说明一下 Pip 的用法。 1.安装包管理工具 2.升级包管理工具 3.安装第三方的模块 4.卸载第三方的模块 1、安装包管理工具 - pip 1sudo easy-install pip 2、升级包管理工具的版本 ​ Linux 或 Mac OS 上： pip install -U pip​ Windows 上： 1python -m pip install -U pip 3、使用包管理工具安装第三方的模块 ​ 举个简单的栗子，使用命令：pip3 install + 模块名。例如安装 PyMySQL 模块，则需要使用命令： pip3 install PyMySQL 4、使用包管理工具卸载模块 使用卸载模块命令即可对相应模块进行移除操作，命令：pip uninstall + 模块名。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Pip</tag>
        <tag>包管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CantuseSubversioncommandlineclient 的解决方案]]></title>
    <url>%2F2018%2F05%2F08%2FCantuseSubversioncommandlineclient%20%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[由于项目在 iPhone X 上出现异常，要对 Xcode 进行9.3版本的更新时，发现也需要对 Mac OS 升级为 10.13.4，不然会出现不兼容的情况，谁叫人家是大哥呢？ 作为一名程序猿，不升级怎么修复 Bug？！ 经过漫长的等待，终于更新好了，咦，Finder 怎么编成“访达”，当然还有其他的一些变化，这是 Apple 在汉语化的结果。真是受不了这翻译，果断切换为英文版。好了废话不多说，当我兴冲冲的打开 Xcode，准备提交更改的代码时候，直接弹出 Can’t use Subversion command line client: svn Probably the path to Subversion executable is wrong. Fix it. 错误。 当出现这个问题的时候，不管你的Mac上边安装的什么IDE，提交SVN的时候都会报 Can’t use Subversion command line client: svn Probably the path to Subversion executable is wrong. Fix it. 错误。下边我贴出的Android Studio的错误信息。 首先来说一下 Windows 下的解决方法：Windows 下的这个错误比较容易解决，重新安装一下SVN，勾选一下 Command line client tools 这个选项，最后在IDE中设置一下 SVN 的相关路径即可。作为一个 Mac 新手，这个问题还是比较棘手，从错误信息来看，是缺少相关的工具。 解决办法： 123打开 Terminal 输入 xcode-select --install ,大概等待2分钟左右安装 Xcode 插件。等待安装完成之后，你就可以开心的提交代码。xcode-select --install 在此记录一下遇到的问题，希望给遇到同样问题的小伙伴一点参考。]]></content>
      <categories>
        <category>CantuseSubversioncommandlineclient</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发者协议更新的错误解决方法]]></title>
    <url>%2F2018%2F04%2F22%2FiOS%20%E5%BC%80%E5%8F%91%E8%80%85%E5%8D%8F%E8%AE%AE%E6%9B%B4%E6%96%B0%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[由于很久没有登陆苹果开发者账号，要不是需要更新App的版本，苹果开发者协议更新导致开发者账号不能正常使用的问题就会遗漏，既然问题来了，那就想办法解决一下喽。 首先贴出错误信息，如下图所示 按照以往的方式直接点击右上角的 Review Agreement，然后同意开发许可协议就可以解决问题，但这次似乎有点不同，提示需要编辑电话，既然不一样，那就直接看错误信息。根据错误信息提示：开发者协议已经更新，你必须接受开发者许可协议，首先你需要更新 Apple ID 的联系方式。 解决办法： 点击 applied.apple.com 链接进入联系方式修改，修改的时候需要提供短信验证码，填写完成后，在返回错误信息页面，直接刷新网页，就会出现如下页面。到这里就跟之前的解决方法是一样的，点击同意开发许可协议，然后点击完成就 OK。 在此记录一下遇到的问题，希望给遇到同样问题的小伙伴一点参考。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>开发者许可协议更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 中字符串的相关用法]]></title>
    <url>%2F2018%2F04%2F02%2FPython%20%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E5%85%B3%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本篇文章主要记录一下Python中关于字符串的相关操作，一来是为了自己加深记忆，二来是方便后期查找起来比较快速。 1、拼接字符串 2、字符串复制 3、字符串长度 4、字符串大小写转换(如果不进行重新赋值操作，原数据是不会发生变化的) 5、给字符串编号(从左到右是是从0开始) 6、字符串截取 7、去掉字符串的空格 1、拼接字符串1.1、使用 + 来拼接，只能操作相同类型12345a = "正在学习"b = "Python"c = a + bprint(c) # 正在学习Python 1.2、使用占位符来拼接字符串1234a = 'Py'b = 'thon'print('%s%s' % (a, b)) # Python 2、字符串复制2.1、使用等号进行字符串的复制12345a = 'copy string...'print(a) # result:copystring...b = aprint(b) # result:copy string... 3、字符串长度使用len()函数获取字符串的长度1234A = 'copy string...'print(A) # result:copy string...print(len(A)) # result:14 4、字符串大小写转换(如果不进行重新赋值操作，原数据是不会发生变化的)4.1、将小写转换成大写1234567a = 'copy, python'a.upper() # 将小写完全变成大写print(a) # result:'COPY, PYTHON'print(a) # result:'copy, python' # 原数据没有改变b = a.upper() # 进行重新赋值，就会发生变化print(b) # result:'COPY, PYTHON' 4.2、将大写转换成小写12c = b.lower()print(c) # result:'copy, python' 4.3、只改变首字符的大小写123456789print(a) # result:'copy, python'a.capitalize() # 改变首字母为大写print(a) # result:'Copy, python'print(a) # result:'copy, python'b = a.capitalize()print(a) # result:'Copy, python'print(b) # result:'copy, python' 4.4、判断首字母是否是大写(不含有逗号，且首字母大写的情况才是正确)12345678a = 'Hello, python' # 含有逗号的情况,直接返回 False。第一个是大写，第二个是小写print(a.istitle()) # result:Falsea = 'Hello, Python'print(a.istitle()) # result:Truea = 'HelloPython'print(a.istitle()) # result:True 4.5、判断字符串是否都是大写1234567a = 'HelloPython'print(a.isupper()) # result:Falseprint(a.upper().isupper()) # result:Truea = 'Hello,Python'print(a.islower()) # result:Falseprint(a.lower().islower()) # result:True 5、给字符串编号(从左到右是是从0开始)123456a = 'Hello, World!'print(len(a)) # result:13print(a[0]) # result:'H'print(a[9]) # result:'r'print(a[-1]) # 从右到左是从-1开始的 result:'!' 6、字符串截取12345a = 'Hello,World'print(a[2:5]) # 从a开始到b结束 result:'llo'print(a[3:]) # 从a开始，截取到结束 # 'lo,World'print(a[:5]) # 从开始位置截取到b位置 # result:'Hello,' 7、去掉字符串的空格123456a = ' Hello 'print(a.strip()) # 去掉前后的空格 # result:'Hello'print(a) # result:' Hello 'print(b.lstrip()) # 去掉前面的空格 # result:'Hello 'print(b.rstrip()) # 去掉后面的空格 # result:' Hello']]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 6.0 权限]]></title>
    <url>%2F2017%2F05%2F24%2FAndroid%206.0%20%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[​ 对于开发者来说，Android应用权限这个词语应该都不会陌生，但是Android 6.0之后，Google做了一些调整： 6.0以前的版本，设置应用权限只要在Manifest清单文件声明相应的权限即可，系统会在用户安装应用的时候告知用户该应用会获取哪些权限，并且会授权声明在配置清单文件的权限。 6.0以后版本（包括6.0），应用在运行时向用户请求权限，用户可以随时调用权限，所以说应用运行时需要检查权限是否授权。 ​ 系统权限分为：正常权限和危险权限，声明在清单文件中的正常权限在应用安装时，直接被授权通过；危险权限需要用户确认授权应用才能获得相应权限，否则相应的功能将不能正常使用。所有的Android危险权限都属于权限组，下边列出开发者官网上的危险权限组和危险权限： ​ 当应用在清单文件中声明以上任意权限，应用在运行的时候，首先会判断该权限是否获得用户的授权，如果获得用户的授权，涉及该权限的功能可以正常使用；反之，未获得用户授权，需要重新向用户请求授权，授权以弹出框的形式展现出来，弹出框告知用户应用内获得哪些权限，由用户选择授权或者是取消授权。换句话说：6.0之后的系统版本，用农户对应用内的权限有更高的控制权。 好了，言归正传，下边举个简单的栗子来说明一下。 步骤一：在清单文件中声明需要用到的权限 步骤二：在布局文件中添加并在代码中初始化Button，点击Button获取清单文件中声明的权限 ![判断是否授权并请求权限](E:\HEXO\themes\next\source\images\判断是否授权并请求权限 .jpg) 分析：首先判断用户是否已经授权，如果已经授权，则直接调用call（）方法；反之，重新使用ActivityCompat.requestPermissions（）向用户请求权限，然后回掉方法中判断请求结果，用户通过授权，则调用Call（）方法；否则吐司提示用户拒绝授权。 最后贴上运行结果图 ![运行结果](E:\HEXO\themes\next\source\images\运行结果 .jpg)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 6.0 权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取 AndroidStudio 的 Share1 值]]></title>
    <url>%2F2016%2F08%2F08%2F%E8%8E%B7%E5%8F%96%20AndroidStudio%20%E7%9A%84%20Share1%20%E5%80%BC%2F</url>
    <content type="text"><![CDATA[这个周末没事，准备做个BaiduMap比较全面的Demo，之前使用Ecplise比较方便，直接复制粘贴就行。但是AndroidStudio获取比较麻烦，刚开始我是一头雾水，不过最终还是研究出来了，记录一下，希望避过我踩过的坑。 步骤： 1、打开AndroidStudio的Terminal。 2、输入keytool -list -keystore D:\Soft\JDK1.8\MyJks.jks 这里需要注意的是：必须是在你存放的JKS文件路径才可以。 3、输入口令，正确之后就可以看到Share1的值 ![显示Share1值 ](/images/显示Share1值 .jpg) 到这里，Share1的值就获取到了，直接复制使用就OK。]]></content>
      <categories>
        <category>AndroidStudio</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AndroidStudio</tag>
        <tag>Share1值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于友盟的第三方登录、分享的流程实现]]></title>
    <url>%2F2016%2F05%2F24%2F%E5%85%B3%E4%BA%8E%E5%8F%8B%E7%9B%9F%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E3%80%81%E5%88%86%E4%BA%AB%E7%9A%84%E6%B5%81%E7%A8%8B%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[现在几乎每款APP都有登陆、分享这些功能，正好最想项目中需要用到。因此记录一下实现的流程。此片博文主要是关于友盟的登陆分享的实现流程。 首先呢，友盟支持的第三方登录平台：新浪微博、腾讯微博、QQ、QQ空间、微信、人人网； 其次呢，友盟支持的第三方的分享平台： 国内的平台：微信（微信好友及微信朋友圈）、QQ、QQ空间、新浪微博、腾讯微博、人人网、支付宝、豆瓣、印象笔记、有道云笔记、来往、易信等。 国外的平台：Facebook、Twitter、Google+、KaKao、Instagram、WhatsApp、Line、EverNote、Pocket、Pinterest、Linkedin、G+等。 （Ps：可能会有人说我根本用不了那么多的平台，其实呢，你只需要在集成SDK的时候，将你需要使用的平台集成进去就好了） 友盟账号注册，添加应用，获取AppKey等这些我就不再这里多说了，因为我相信大家都是老司机，轻车熟路。但是下载SDK的时候，只需要下载自己将用到的东西就OK。 最后呢，就是那个集成流程： 在Manifest中添加友盟的权限，AppKey，登陆分享的组件。 添加jar和资源文件。 在代码中设置要分享的内容和制定分享平台。 在指定的各个平台申请账号，添加应用。 注：官方的文档是比较详细的，具体请戳这里：[http://dev.umeng.com/social/android/sdk-download?spm=0.0.0.0.g0iA18](]]></content>
      <categories>
        <category>友盟，第三方登录、分享</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
